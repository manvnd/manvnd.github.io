<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="redis">
<meta property="og:url" content="http://example.com/2023/09/18/redis/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/09/18/redis/duanxindenglu.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/tianjiaredishuancun.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/huchisuo.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/luojiguoqi.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/Redissonkechongrusuoyuanli.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/zhucongdiyicitongbu.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/zengliangtongbu.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/shaobingjiegou.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/shujuqianyi.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/duojihuancun.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/Stringcunchujiegou.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/SetStruct.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/ZSetStruct.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/HashStruct.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/LinuxRead.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/blockIO.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/NoBlockIO.png">
<meta property="og:image" content="http://example.com/Users/yucan/Desktop/redis/IOEpoll.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/SelectSequence.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/epollSequence.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/RedisNetStruct.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/RedisDBStruct.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/expireMethod.png">
<meta property="article:published_time" content="2023-09-18T07:59:53.000Z">
<meta property="article:modified_time" content="2023-09-18T08:21:48.065Z">
<meta property="article:author" content="MANVND">
<meta property="article:tag" content="JavaWeb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/09/18/redis/duanxindenglu.png">

<link rel="canonical" href="http://example.com/2023/09/18/redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>redis | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/18/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MANVND">
      <meta itemprop="description" content="There is no royal road to learning">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2023-09-18 15:59:53 / Modified: 16:21:48" itemprop="dateCreated datePublished" datetime="2023-09-18T15:59:53+08:00">2023-09-18</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <html><head></head><body><h1 id="Redis基础使用"><a href="#Redis基础使用" class="headerlink" title="Redis基础使用"></a>Redis基础使用</h1><h2 id="NoSQL特性"><a href="#NoSQL特性" class="headerlink" title="NoSQL特性"></a>NoSQL特性</h2><ul>
<li>数据结构：数据往往以非结构化的方式存储</li>
<li>数据关联：无关联的</li>
<li>查询方式：非SQL语句查询</li>
<li>事务特性：无法满足ACID，而是BASE</li>
<li>存储方式：内存</li>
<li>拓展性：水平</li>
</ul>
<h2 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h2><p>基于<strong>内存</strong>的键值型NoSQL数据库。</p>
<ul>
<li>键值型，value支持多种不同数据结构，功能丰富；</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（基于内存、IO多路复用、良好的编码）</li>
<li>支持数据持久化</li>
<li>支持主从集群、分片集群</li>
</ul>
<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis是一个key-value数据库，key一般是String类型，value的类型多种多样：</p>
<p>String, Hash, List, Set, SortedSet, GEO, BitMap, HyperLog</p>
<h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>通用命令是不分数据类型的，都可以使用的指令，常见的有：</p>
<ul>
<li>KEYS：查看符合模板的所有key，后接匹配模式pattern，不建议在生产环境设备上使用</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEYS *</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>DEL：删除一个指定key，后接一个或多个key的名称</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL keyName</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>EXISTS：查看一个key是否存在，后接key的名称</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS keyName</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>EXPIRE：给一个key设置有效期，有效期到期key会自动被删除</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE keyName time</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>TTL：查看一个key的剩余有效期</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TTL keyName</span><br></pre></td></tr></tbody></table></figure>

<p>可以通过help[command]查看一个命令的具体用法。</p>
<h2 id="String类型命令"><a href="#String类型命令" class="headerlink" title="String类型命令"></a>String类型命令</h2><p>String类型是Redis中最简单的存储类型。其value是字符串，但根据字符串的格式不同，可以分为三类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增、自减操作</li>
<li>float：浮点类型，可以做自增、自减操作</li>
</ul>
<p>不管哪种格式，其底层都是用<strong>字节数组</strong>形式存储，只不过编码方式不同。字符串类型的最大空间不能超过512m。</p>
<p>String的常见命令有：</p>
<ul>
<li>SET：添加或修改已经存在的一个String类型的键值对</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [NX | XX] [GET] [EX seconds | PX milliseconds | EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>GET：根据key获取String类型的value</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>MSET：批量添加多个String类型的键值对</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>MGET：根据多个key获取多个String类型的value</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MGET key [key ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>INCR：让一个整形的key的值自增1</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>INCRBY：让一个整形的key的值自增并指定步长</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBY key increment</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBYFLOAT key increment</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SETEX：添加一个String类型的键值对，并且指定有效期</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETEX key seconds value</span><br></pre></td></tr></tbody></table></figure>

<h2 id="key的结构"><a href="#key的结构" class="headerlink" title="key的结构"></a>key的结构</h2><p>Redis的key允许多个单词形成层级结构，多个单词之间用’.’隔开，格式如下：</p>
<p>项目名:业务名:类型:id</p>
<h2 id="Hash类型命令"><a href="#Hash类型命令" class="headerlink" title="Hash类型命令"></a>Hash类型命令</h2><p>Hash类型，也叫散列，其value是一个无序字，类似于Java中的HashMap结构。</p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。</p>
<table>
  <tbody text-align="center">
    <tr>
        <th rowspan="2">KEY</th>
      <th colspan="2">VALUE</th>
    </tr>
      <tr>
        <td>field</td>
      <td>value</td>
    </tr>
  </tbody>
</table>


<p>Hash类型的常见命令：</p>
<ul>
<li>HSET: 添加或修改hash类型key的field的值</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HGSET：获取一个hash类型key的filed的值</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGET key field</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HMSET：批量添加多个hash类型key的field的值</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMSET key field value [field value ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HMGET：批量获取多个hash类型key的field的值</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field [field ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HGETALL：获取一个hash类型的key中的所有field和value</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGETALL key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HKEYS：获取一个hash类型的key中所有的field</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEYS key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HVALS：获取一个hash类型的key中的所有value</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HVALS key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HINCRBY：让一个hash类型key的字段值自增并指定步长</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行。</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX key field value</span><br></pre></td></tr></tbody></table></figure>

<h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做一个双向链表结构。既可以正向检索也可以反向检索</p>
<p>特征：</p>
<ul>
<li>有序</li>
<li>元素可以重复插入</li>
<li>插入和删除块</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据</p>
<p>List的常见命令有：</p>
<ul>
<li>LPUSH：向列表左侧插入一个或多个元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key element [element ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>LPOP：移除并返回列表左侧的第一个元素，没有返回null</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPOP key [count]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>RPUSH：向列表右侧插入一个或多个元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSH key element [element ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>RPOP：移除并返回列表右侧第一个元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOP key [count]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>LRANGE：返回一段角标范围内的所有元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>BLPOP与BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回null</li>
</ul>
<h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具有与HashSet类似的特征：</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集、并集、差集等功能</li>
</ul>
<p>Set的常见命令有：</p>
<ul>
<li>SADD：向set中添加一个或多个元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SREM：移除set中的指定元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SCARD：返回set中元素的个数</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SISMEMBER：判断一个元素是否存在于set中</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SMEMBERS：获取set中的所有元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SINTER：求key1与key2的交集</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SDIFF：求key1与key2的差集</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key [key ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SUNION：求key1与key2的并集</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNION key [key ...]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis的Sorted是一个可排序的set集合，与Java中的TreeSet功能类似，但底层数据结构差别很大。SortedSet中的每个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表加hash表</p>
<p>SortedSet具有以下特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>SortedSet的常见命令有：</p>
<ul>
<li>ZADD：添加一个或多个元素到sorted set，如果已经存在则更新其score值</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZREM：删除sorted set中的一个指定元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZSCORE：获取sorted set中的指定元素的score值</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZRANK：获取sorted set中的指定元素的排名</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANK key member [WITHSCORE]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZCARD：获取sorted set 中的元素个数</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZCOUNT：统计score值在给定范围内的所有元素的个数</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZINCRBY：让sorted set中的指定元素自增，步长为指定的increment值</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZRANGE：按照score排序后，获取指定排名范围内的元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZRANGEBYSCORE：按照score排序后，获取指定score范围内的元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li>
</ul>
<p>所有排名默认升序，如果要降序则在命令Z后添加<strong>REV</strong>即可</p>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此可以使用Jedis连接池</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        jedisPoolConfig.setMaxWait(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig, <span class="string">"127.0.0.1"</span>, <span class="number">6379</span>, <span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedisPool</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h1 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h1><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫SpringDataRedis</p>
<ul>
<li>提供了对不同Redis客户端的整合</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持给予JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<h2 id="SpringDataRedis快速使用"><a href="#SpringDataRedis快速使用" class="headerlink" title="SpringDataRedis快速使用"></a>SpringDataRedis快速使用</h2><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并将不同数据类型的操作API封装到了不同的类型中</p>
<table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">返回值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">redisTemplate.opsForValue()</td>
<td align="center">ValueOperations</td>
<td align="center">操作String类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate.opsForHash()</td>
<td align="center">HashOperatiions</td>
<td align="center">操作Hash类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate.opsForList()</td>
<td align="center">ListOperations</td>
<td align="center">操作List类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate.opsForSet()</td>
<td align="center">SetOperations</td>
<td align="center">操作Set类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate.opsForZSet()</td>
<td align="center">ZSetOperations</td>
<td align="center">操作SortedSet类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate</td>
<td align="center"></td>
<td align="center">通用的命令</td>
</tr>
</tbody></table>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 最大连接</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment"># 最大空闲连接</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment"># 最小空闲连接</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="number">100</span> <span class="comment"># 连接等待时间</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="注入RedisTemplate"><a href="#注入RedisTemplate" class="headerlink" title="注入RedisTemplate"></a>注入RedisTemplate</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> REdisTemplate redisTemplate</span><br></pre></td></tr></tbody></table></figure>

<h2 id="SpringDataRedis的序列化方式"><a href="#SpringDataRedis的序列化方式" class="headerlink" title="SpringDataRedis的序列化方式"></a>SpringDataRedis的序列化方式</h2><p>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认采用JDK序列化</p>
<p>缺点：</p>
<ul>
<li>可读性差</li>
<li>内存占用较大</li>
</ul>
<p>可以自定义RedisTemplate的序列化方式：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> {</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置value的序列化</span></span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>为了实现序列化与反序列化，Template会在Redis数据库中存储”@Class”保存该数据的类，但因此也会产生额外的内存开销</p>
<p>为了节省空间，一般不会用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化</p>
<p>Spring默认提供一个StringRedisTemplate类，它的key和value的序列化默认就是String方式</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException {</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">"虎哥"</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">// 手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">"user:100"</span>, json);</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">"user:100"</span>);</span><br><span class="line">        <span class="comment">// 手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="Session实现用户短信登录"><a href="#Session实现用户短信登录" class="headerlink" title="Session实现用户短信登录"></a>Session实现用户短信登录</h2><p><img src="/2023/09/18/redis/duanxindenglu.png" alt="duanxindenglu"></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="缓存的简介"><a href="#缓存的简介" class="headerlink" title="缓存的简介"></a>缓存的简介</h3><p><strong>缓存</strong>就是数据交换的缓冲区，是存储数据的临时地方，一般读写性能较高。</p>
<p>浏览器：浏览器缓存</p>
<p>tomcat：应用层缓存</p>
<p>数据库：数据库缓存</p>
<p>作用：</p>
<ul>
<li>降低后端负载</li>
<li>提高读写效率，降低响应时间</li>
</ul>
<p>成本：</p>
<ul>
<li>数据一致性成本</li>
<li>代码维护成本</li>
<li>运维成本</li>
</ul>
<h3 id="添加Redis缓存"><a href="#添加Redis缓存" class="headerlink" title="添加Redis缓存"></a>添加Redis缓存</h3><p><img src="/2023/09/18/redis/tianjiaredishuancun.png" alt="tianjiaredishuancun"></p>
<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><table>
<thead>
<tr>
<th></th>
<th>内存淘汰</th>
<th>超时剔除</th>
<th>主动更新</th>
</tr>
</thead>
<tbody><tr>
<td><strong>说明</strong></td>
<td>不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存</td>
<td>给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存</td>
<td>编写业务逻辑，在修改数据库的同时，更新缓存</td>
</tr>
<tr>
<td><strong>一致性</strong></td>
<td>差</td>
<td>一般</td>
<td>好</td>
</tr>
<tr>
<td><strong>维护成本</strong></td>
<td>无</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><ol>
<li>由缓存的调用者，在更新数据库的同时更新缓存</li>
</ol>
<ul>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li>
<li>单体系统：将缓存与数据库操作放在一个事务；分布式系统，利用TTC等分布式事务方案</li>
</ul>
<ol>
<li>缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题</li>
<li>调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保持最终一致</li>
</ol>
<p>最佳实践方案：</p>
<ol>
<li>低一致性需求：使用Redis自带的内存淘汰机制</li>
<li>高一致性需求：主动更新，并以超时剔除作为兜底方案</li>
</ol>
<ul>
<li>读操作：<ul>
<li>缓存命中则直接返回</li>
<li>缓存命中则查询数据库，并写入缓存，设定超时时间</li>
</ul>
</li>
<li>写操作：<ul>
<li>先写数据库，然后再删除缓存</li>
<li>要确保数据库与缓存操作的原子性</li>
</ul>
</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都回到数据库</p>
<ul>
<li>缓存空对象：当将空对象存储在缓存中<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤：在客户端与缓存间添加一层——布隆过滤器<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>缓存雪崩</strong>指同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力</p>
<p>解决方案：</p>
<ul>
<li>给不同key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务天假降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿问题</strong>也叫热点key问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求会在瞬间给数据库带来巨大的冲击</p>
<p>常见解决方案：</p>
<ul>
<li>互斥锁</li>
</ul>
<p><img src="/2023/09/18/redis/huchisuo.png" alt="huchisuo"></p>
<ul>
<li>逻辑过期</li>
</ul>
<p><img src="/2023/09/18/redis/luojiguoqi.png" alt="luojiguoqi"></p>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>互斥锁</td>
<td>- 没有额外的内存消耗<br>- 保证一致性<br>- 实现简单</td>
<td>- 线程需要等待，性能受到影响 <br>- 可能有死锁风险</td>
</tr>
<tr>
<td>逻辑过期</td>
<td>- 线程无需等待，性能较好</td>
<td>- 不保证一致性<br>- 有额外的内存消耗<br>- 实现复杂</td>
</tr>
</tbody></table>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul>
<li><p>悲观锁：认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。</p>
</li>
<li><p>乐观锁：认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其他线程对数据做了修改。</p>
<ul>
<li>如果没有修改则认为是安全的，自己才更新数据；</li>
<li>如果已经被其他线程修改说明发生了安全问题，此时可以重试或异常</li>
</ul>
</li>
</ul>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁的关键是判断之前查询得到的数据是否有被修改过</p>
<h4 id="CAS法"><a href="#CAS法" class="headerlink" title="CAS法"></a>CAS法</h4><p>给数据添加版本号，根据版本号是否变化判断是否有别的线程修改了数据</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁</p>
<p>分布式锁的核心是实现多进程之间的互斥，而满足这一点的方式有很多，常见的有三种：</p>
<table>
<thead>
<tr>
<th></th>
<th>MySQL</th>
<th>Redis</th>
<th>Zookeeper</th>
</tr>
</thead>
<tbody><tr>
<td>互斥</td>
<td>利用MySQL本身的互斥锁机制</td>
<td>利用setnx这样的互斥命令</td>
<td>利用节点的唯一性和有序性实现互斥</td>
</tr>
<tr>
<td>高可用</td>
<td>好</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>高性能</td>
<td>一般</td>
<td>好</td>
<td>一般</td>
</tr>
<tr>
<td>安全性</td>
<td>断开连接，自动释放锁</td>
<td>利用锁超时时间，到期释放</td>
<td>临时节点，断开连接自动释放</td>
</tr>
</tbody></table>
<h4 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h4><p>实现分布式锁时需要实现的两个基本方法：</p>
<ul>
<li>获取锁：<ul>
<li>互斥：确保只能有一个线程获取锁</li>
</ul>
</li>
<li>释放锁：<ul>
<li>手动释放</li>
<li>超时释放：获取锁时添加一个超时时间</li>
</ul>
</li>
</ul>
<h4 id="改进Redis的分布式锁"><a href="#改进Redis的分布式锁" class="headerlink" title="改进Redis的分布式锁"></a>改进Redis的分布式锁</h4><ol>
<li>在获取锁时存入线程标识；</li>
<li>在释放锁时先获取锁的线程标识，判断是否与当前线程标识一致<ul>
<li>如果一致则释放锁</li>
<li>如果不一致则不释放锁</li>
</ul>
</li>
</ol>
<h4 id="Redis的Lua脚本"><a href="#Redis的Lua脚本" class="headerlink" title="Redis的Lua脚本"></a>Redis的Lua脚本</h4><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。</p>
<h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包括了各种分布式锁的实现</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 配置类</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 添加redis地址，这里添加单点地址，也可以使用config.useClusterServers()添加集群地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>);</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    }</span><br><span class="line">            </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Redisson可重入锁的原理"><a href="#Redisson可重入锁的原理" class="headerlink" title="Redisson可重入锁的原理"></a>Redisson可重入锁的原理</h3><img src="/2023/09/18/redis/Redissonkechongrusuoyuanli.png" alt="Redissonkechongrusuoyuanli" style="zoom:50%;">

<p>使用Lua脚本完成上图逻辑保证原子性</p>
<h3 id="Redisson分布式的原理"><a href="#Redisson分布式的原理" class="headerlink" title="Redisson分布式的原理"></a>Redisson分布式的原理</h3><ul>
<li><strong>可重入</strong>： 利用hash结构记录线程id和重入次数</li>
<li><strong>可重试</strong>：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</li>
<li><strong>超时续约</strong>：利用watchDog，每隔一段时间（realeaseTime / 3），重置超时时间</li>
</ul>
<h3 id="Redisson分布式锁主从一致性问题"><a href="#Redisson分布式锁主从一致性问题" class="headerlink" title="Redisson分布式锁主从一致性问题"></a>Redisson分布式锁主从一致性问题</h3><p>主从模式：主节点处理写操作，从节点处理读操作</p>
<p>一致性问题：主操作更新的数据还没来得及同步到从节点，此时发生一致性问题</p>
<p>Redisson取消主从模式，所有节点均为主节点，一个应用要同时获取多个节点的锁才能获取读写操作</p>
<p>Redisson的multiLock：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功；缺陷：运维成本高，实现复杂</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列(Message Queue)，即存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也被称为消息代理；</li>
<li>生产者：发送消息到消息队列；</li>
<li>消费者：从消息队列获取消息并处理消息；</li>
</ul>
<p>Redis提供三种不同的方式来实现消息队列：</p>
<ul>
<li>list结构：基于list结构模拟消息队列</li>
<li>PubSub：基本的点对点消息模型</li>
<li>Stream：比较完善的消息队列模型</li>
</ul>
<h3 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a>基于List结构模拟消息队列</h3><p>队列的入口和出口不在一边，因此可以利用LPUSH结合RPOP、或者RPUSH结合LPOP来实现，不过，当队列中没有消息的时候RPOP或LPLP操作会返回null，并不会像JVM的阻塞队列那样阻塞并等待消息，因此应该使用<strong>BRPOP</strong>或者<strong>BLPOP</strong>来实现阻塞效果</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>基于Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保证</li>
<li>可以满足消息有序性</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>无法避免消息丢失</li>
<li>只支持单消费者</li>
</ul>
<h3 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息</p>
<ul>
<li>SUBSCRIBE channel [channel]: 订阅一个或多个频道</li>
<li>PUBLISH channel msg: 向一个频道发送消息</li>
<li>PSUBSCRIBE pattern [pattern]: 订阅与pattern格式匹配的所有频道</li>
</ul>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>采用发布订阅模型，支持多生产，多消费</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不支持数据持久化</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失</li>
</ul>
<h3 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h3><p>Stream是Redis5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列</p>
<p>发送消息的命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD key [NOMKSTREAM] [MAXLEN|MINID [=|~] threshold [LIMIT count]] *|ID field value [field value ...]</span><br></pre></td></tr></tbody></table></figure>

<p>读取消息的命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREAD [COUNT count] [BLOCK milliseconds] [STREAMS key [key ...] ID [ID ...]]</span><br></pre></td></tr></tbody></table></figure>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h3 id="基于Stream的消息队列-消费者组"><a href="#基于Stream的消息队列-消费者组" class="headerlink" title="基于Stream的消息队列-消费者组"></a>基于Stream的消息队列-消费者组</h3><p>消费者组：将对个消费者划分到一个组中，监听同一个队列。具有如下特点：</p>
<ol>
<li>消息分流：队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度</li>
<li>消息标示：消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费</li>
<li>消息确认：消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记该消息为已处理，才会从pending-list移除</li>
</ol>
<p>创建消费者组：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE key groupName ID [MKSTREAM]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>key：队列名称</li>
<li>groupName：消费者组名称</li>
<li>ID：起始ID标示，￥标示队列中最后一个消息，0则代表队列中第一个消息</li>
<li>MKSTREAM：队列不存在时自动创建队列</li>
</ul>
<p>其他常见命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定的消费者组</span></span><br><span class="line">XGROUP DESTROY key groupName</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给指定的消费者组天假消费者</span></span><br><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除消费者组中的指定消费者</span></span><br><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></tbody></table></figure>

<p>从消费者组读取消息：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>group：消费组名称</li>
<li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li>
<li>count：本次查询的最大数量</li>
<li>BLOCK milliseconds：当没有消息时最长等待时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认</li>
<li>STREAMS key：指定消息名称</li>
<li>ID：获取消息的起始ID：<ul>
<li>“&gt;”：从下一个未消费的消息开始</li>
<li>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</li>
</ul>
</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消费漏读风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
<h2 id="GEO数据结构"><a href="#GEO数据结构" class="headerlink" title="GEO数据结构"></a>GEO数据结构</h2><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本加入了对GEO的支持，允许存储地理坐标信息。常见的命令有：</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包括经度（longitude）、维度（latitude）、值（member）</li>
<li>GEODIST：计算指定的两个点之间的距离并返回</li>
<li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li>
<li>GEOPOS：返回指定member的坐标</li>
<li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回</li>
<li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形</li>
<li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以吧结果存储到一个指定的key</li>
</ul>
<h2 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h2><p>位图，将每个bit位与业务对应，0，1表示业务状态。</p>
<p><strong>Redis</strong>中利用string类型数据结构实现<strong>BitMap</strong>，因此最大上限是512M，转换bit则是2^32个bit位</p>
<p>BitMap的操作命令有：</p>
<ul>
<li>SETBIT：向指定位置（offset）存入一个0或1</li>
<li>GETBIT：获取指定位置（offset）的bit值</li>
<li>BITCOUNT：统计BitMap中值为1的bit位的数量</li>
<li>BITFIELD：操作（查询、修改、自增）BitMap中bit数组中指定位置（offset）的值</li>
<li>BITFIELD_RO：获取BitMap中bit数组，并以十进制形式返回</li>
<li>BITOP：将多个BitMap的结果做位运算（与、或、异或）</li>
<li>BITPOS：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
<h2 id="HyperLogLog用法"><a href="#HyperLogLog用法" class="headerlink" title="HyperLogLog用法"></a>HyperLogLog用法</h2><ul>
<li>UV：全称Unique Visitor，也叫独立访问量，指通过互联网那个访问、浏览这个网页的自然人。一天内同一个用户多次访问该网站，只记录一次</li>
<li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量</li>
</ul>
<p>HyperLogLog（HLL）是从LogLog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。</p>
<p>Redis中的HLL是基于string结构实现的，单个HLL的内存永远小于16kb，内存占用低，作为代价，有小于0.81%的误差。不过对于UV统计来说，这完全可以忽略</p>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB全程Redis Database Backup file（Redis数据备份文件），也叫做Redis数据快照。即把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据</p>
<p>快照文件称为RDB文件，默认保存在当前目录</p>
<ul>
<li>save：由Redis主进程来执行RDB，会阻塞所有命令</li>
<li>bgsave：开启子进程执行RDB，避免主进程收到影响</li>
</ul>
<p>RDB停机时会执行一次RDB</p>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">900秒内，如果至少有1个key被修改，则执行bgsave，如果save <span class="string">""</span> 则表示禁用RDB</span></span><br><span class="line">save &lt;seconds&gt; &lt;change&gt;</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></tbody></table></figure>

<p>RDB的其它配置也可以在redis.conf文件中设置：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否压缩，建议不开启，压缩会消耗CPU，磁盘不值钱</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RDB文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件保存的路径目录</span></span><br><span class="line">dir ./</span><br></pre></td></tr></tbody></table></figure>

<p>bgsave开始时会fork主进程得到子进程，子进程<strong>共享</strong>主进程的内存数据。完成fork后读取内存数据并写入RDB文件</p>
<p>fork采取的是copy-on-write技术：</p>
<ul>
<li>当主进程执行读操作时，访问共享内存</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作</li>
</ul>
<h5 id="RDB方式bgsave的执行流程"><a href="#RDB方式bgsave的执行流程" class="headerlink" title="RDB方式bgsave的执行流程"></a>RDB方式bgsave的执行流程</h5><ul>
<li>fork主进程得到一个子进程，共享内存空间</li>
<li>子进程读取内存数据并写入新的RDB文件</li>
<li>用新的RDB文件替换旧的RDB文件</li>
</ul>
<h5 id="RDB的执行时机"><a href="#RDB的执行时机" class="headerlink" title="RDB的执行时机"></a>RDB的执行时机</h5><ul>
<li>默认是服务停止时</li>
</ul>
<h5 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a>RDB的缺点</h5><ul>
<li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li>
<li>fork子进程、压缩、写入数据有数据丢失的风险</li>
</ul>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF全程为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看作是命令日志文件</p>
<p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否开启AOF功能，默认是no</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF文件的名称</span></span><br><span class="line">appendfilename "appendonly.aof"</span><br></pre></td></tr></tbody></table></figure>

<p>AOF的命令记录的频率也可以通过redis.cnf文件来配置：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示每执行一次写命令，立刻记录到AOF文件</span></span><br><span class="line">appendfsync always</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写命令执行完先放入AOF缓冲区，然后表示每隔一秒讲缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写命令执行完先放入AOF缓冲区，由操作系统决定何时讲缓冲区内容写回磁盘</span></span><br><span class="line">appendfsync no</span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th>配置项</th>
<th>刷盘时机</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Always</td>
<td>同步刷盘</td>
<td>可靠性高，几乎不丢失数据</td>
<td>性能影响大</td>
</tr>
<tr>
<td>everysec</td>
<td>每秒刷盘</td>
<td>性能适中</td>
<td>最多丢失一秒数据</td>
</tr>
<tr>
<td>no</td>
<td>操作系统控制</td>
<td>性能最好</td>
<td>可靠性较差，可能丢失大量数据</td>
</tr>
</tbody></table>
<p>因为记录命令，AOF文件会比RDB文件大很多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行<strong>bgrewriteaof</strong>命令，可以让AOF文件执行重写功能，用最少得命令达到相同效果</p>
<p>Redis也会在触发阈值时自动重写AOF文件。阈值也可以在redis.conf中配置</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF文件体积最小多大以上才触发重写</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></tbody></table></figure>

<h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RDB</th>
<th align="center">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">持久化方式</td>
<td align="center">定时对整个内存做快照</td>
<td align="center">记录每一次执行的命令</td>
</tr>
<tr>
<td align="center">数据完整性</td>
<td align="center">不完整，两次备份之间会丢失</td>
<td align="center">相对完整，取决于刷盘策略</td>
</tr>
<tr>
<td align="center">文件大小</td>
<td align="center">会有压缩，文件体积小</td>
<td align="center">记录命令，文件体积很大</td>
</tr>
<tr>
<td align="center">宕机回复速度</td>
<td align="center">很快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">数据恢复优先级</td>
<td align="center">低，因为数据完整性不如AOF</td>
<td align="center">高，因为数据完整性更高</td>
</tr>
<tr>
<td align="center">系统资源占用</td>
<td align="center">高，大量CPU和内存消耗</td>
<td align="center">低，主要是磁盘IO资源但AOF重写时会赵勇大量CPU和内存资源</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">可以容忍数分钟的数据丢失，追求更高的启动速度</td>
<td align="center">对数据安全性要求较高，常见</td>
</tr>
</tbody></table>
<h3 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h3><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离</p>
<p>master节点负责写操作，slave/replica节点负责读操作</p>
<h5 id="数据同步原理"><a href="#数据同步原理" class="headerlink" title="数据同步原理"></a>数据同步原理</h5><img src="/2023/09/18/redis/zhucongdiyicitongbu.png" alt="zhucongdiyicitongbu" style="zoom:50%;">

<p>master判断slave是否是第一次同步数据的依据：</p>
<ul>
<li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li>
<li><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新</li>
</ul>
<p>因为slave做数据同步，必须向master声明自己的<strong>replication id</strong>和<strong>offset</strong>，master才可以判断到底需要同步哪些数据</p>
<p>上图1.1中<strong>通过判断主从节点的replid是否一致来判断主从节点是否是第一次同步</strong></p>
<h5 id="全量同步的原理"><a href="#全量同步的原理" class="headerlink" title="全量同步的原理"></a>全量同步的原理</h5><ul>
<li>slave节点请求增量同步</li>
<li>master节点判断replid，发现不一致，拒绝增量同步</li>
<li>master将完整内存数据生成RDB，发送RDB到slave</li>
<li>slave清空本地数据，加载master的RDB</li>
<li>master将RDB期间的命令记录到repl_baklog，并持续将log中的命令发送个slave</li>
<li>slave执行接收到的命令，保持与master之间的同步</li>
</ul>
<img src="/2023/09/18/redis/zengliangtongbu.png" alt="zengliangtongbu" style="zoom:50%;">

<p>repl_baklog大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于log做增量同步，只能再次全量同步</p>
<p>可以从以下几个方面优化Redis主从集群：</p>
<ul>
<li>在master中配置repl_diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO</li>
<li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li>
<li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li>
<li>限制一个master上的slave节点数量，如果是在是太多slave，则可以采用主-从-从链式结构，减少master压力</li>
</ul>
<h5 id="全量同步与增量同步的区别"><a href="#全量同步与增量同步的区别" class="headerlink" title="全量同步与增量同步的区别"></a>全量同步与增量同步的区别</h5><ul>
<li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令记录到repl_baklog，逐个发送给slave</li>
<li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li>
</ul>
<h5 id="执行全量同步时机"><a href="#执行全量同步时机" class="headerlink" title="执行全量同步时机"></a>执行全量同步时机</h5><ul>
<li>slave节点第一次连接master节点时</li>
<li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li>
</ul>
<h5 id="执行增量同步时机"><a href="#执行增量同步时机" class="headerlink" title="执行增量同步时机"></a>执行增量同步时机</h5><ul>
<li>slave节点断开又恢复，并且在repl_baklog中能找到offset时</li>
</ul>
<h3 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h3><h4 id="哨兵的作用"><a href="#哨兵的作用" class="headerlink" title="哨兵的作用"></a>哨兵的作用</h4><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p>
<ul>
<li><strong>监控</strong>：Sentinel会不断检查master和slave是否按预期工作</li>
<li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例回复后也以新的master为主</li>
<li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最近信息推送给Redis的客户端</li>
</ul>
<p>结构：</p>
<img src="/2023/09/18/redis/shaobingjiegou.png" alt="shaobingjiegou" style="zoom:67%;">

<h4 id="服务状态监控"><a href="#服务状态监控" class="headerlink" title="服务状态监控"></a>服务状态监控</h4><p>Sentinel基于心跳机制监测服务状态，每隔一秒向集群的每个实例发送ping命令：</p>
<ul>
<li>主观下线：如果某个sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong></li>
<li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最后超过Sentinel实例数量的一半</li>
</ul>
<h4 id="选举新的master"><a href="#选举新的master" class="headerlink" title="选举新的master"></a>选举新的master</h4><p>一旦发现master故障，sentine需要在slave中选择一个作为新的master，选择依据是：</p>
<ul>
<li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li>
<li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li>
<li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li>
<li>最后判断slave节点的运行id大小，越小优先级越高</li>
</ul>
<h4 id="实现故障转移"><a href="#实现故障转移" class="headerlink" title="实现故障转移"></a>实现故障转移</h4><p>当选中了其中一个slave为新的master后，故障的转移步骤如下：</p>
<ul>
<li>sentinel给备选的slave节点发送slaveof no one命令，让该节点成为master</li>
<li>sentinel给所有其他slave发送slaveof &lt;ip&gt; &lt;端口&gt;命令，让这些slave成为新master的从节点，开始从新的master上同步数据</li>
<li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的maaster的slave节点</li>
</ul>
<h4 id="Sentinel的三个作用"><a href="#Sentinel的三个作用" class="headerlink" title="Sentinel的三个作用"></a>Sentinel的三个作用</h4><ul>
<li>监控</li>
<li>故障转移</li>
<li>通知</li>
</ul>
<h4 id="RedisTemplate的哨兵模式"><a href="#RedisTemplate的哨兵模式" class="headerlink" title="RedisTemplate的哨兵模式"></a>RedisTemplate的哨兵模式</h4><p>在Sentinel集群监督下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知与自动切换</p>
<h3 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h3><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>
<ul>
<li>海量数据存储问题</li>
<li>高并发写的问题</li>
</ul>
<p>使用分片集群可以解决上述问题，分片集群特征：</p>
<ul>
<li>集群中有多个master，每个master保存不同数据</li>
<li>每个master都可以有多个slave节点</li>
<li>master之间通过ping监测彼此健康状态</li>
<li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</li>
</ul>
<h4 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h4><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到</p>
<p>数据key不是与节点绑定，而是与插槽绑定。redis回根据key的有小部分计算插槽，分两种情况：</p>
<ul>
<li>kay中包含”{}”，且”{}”中至少包含1个字符，”{}”中的部分是有效部分</li>
<li>key中不包含”{}”，整个key都是有效部分</li>
</ul>
<p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值</p>
<h5 id="Redis判断key与实例的对应关系"><a href="#Redis判断key与实例的对应关系" class="headerlink" title="Redis判断key与实例的对应关系"></a>Redis判断key与实例的对应关系</h5><ul>
<li>将16384个插槽分配给不同的实例</li>
<li>根据key的有效部分计算哈希值，对16384取余</li>
<li>余数作为插槽，寻找插槽所在实例即可</li>
</ul>
<h5 id="将一类数据固定保存到同一个Redis实例的方式"><a href="#将一类数据固定保存到同一个Redis实例的方式" class="headerlink" title="将一类数据固定保存到同一个Redis实例的方式"></a>将一类数据固定保存到同一个Redis实例的方式</h5><ul>
<li>这一类数据使用相同的有效部分，例如key都以{key_prfiex}为前缀</li>
</ul>
<h4 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h4><p>Redis-cli –cluster提供了很多操作集群的命令</p>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>当集群中有一个master宕机：</p>
<ol>
<li>首先是该实例与其他实例失去连接</li>
<li>然后疑似宕机</li>
<li>最后确定下线，自动提升一个slave为新的master</li>
</ol>
<h5 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h5><p>利用cluster failvoer命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。流程如下：</p>
<img src="/2023/09/18/redis/shujuqianyi.png" alt="shujuqianyi" style="zoom:50%;">

<p>手动的Failover支持三种不同模式：</p>
<ul>
<li>缺省：默认的流程，如图1~6步</li>
<li>force：省略了对offset的一致性校验</li>
<li>takeover：直接执行第五步，忽略数据一致性、忽略master状态和其他master的意见</li>
</ul>
<h4 id="RedisTemplate访问分片集群"><a href="#RedisTemplate访问分片集群" class="headerlink" title="RedisTemplate访问分片集群"></a>RedisTemplate访问分片集群</h4><p>RedisTemplate底层同样给予lettuce实现了分片集群的访问，而使用的步骤与哨兵模式基本一致：</p>
<ol>
<li>引入redis的starter依赖</li>
<li>配置分片集群地址</li>
<li>配置读写分离</li>
</ol>
<p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spirng:</span></span><br><span class="line">	<span class="attr">redis:</span></span><br><span class="line">		<span class="attr">cluster:</span></span><br><span class="line">			<span class="attr">nodes:</span> <span class="comment"># 指定分片集群的每一个节点信息</span></span><br><span class="line">				<span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7001</span></span><br><span class="line">				<span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7002</span></span><br><span class="line">				<span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7003</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><h4 id="传统缓存的问题"><a href="#传统缓存的问题" class="headerlink" title="传统缓存的问题"></a>传统缓存的问题</h4><p>传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，存在以下问题：</p>
<ul>
<li>请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈</li>
<li>Redis缓存失效时，会对数据库产生冲击</li>
</ul>
<h4 id="多级缓存方案"><a href="#多级缓存方案" class="headerlink" title="多级缓存方案"></a>多级缓存方案</h4><p>多级缓存就是充分利用请求处理的各个环节，分别添加缓存，减轻Tomcat压力，提升服务性能</p>
<p>用作缓存的Nginx是业务Nginx，需要部署为集群，再有专门的Nginx用来做反向代理</p>
<img src="/2023/09/18/redis/duojihuancun.png" alt="duojihuancun" style="zoom:67%;">

<h4 id="JVM进程缓存"><a href="#JVM进程缓存" class="headerlink" title="JVM进程缓存"></a>JVM进程缓存</h4><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="Redis数据结构-1"><a href="#Redis数据结构-1" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h3 id="动态字符串SDS"><a href="#动态字符串SDS" class="headerlink" title="动态字符串SDS"></a>动态字符串SDS</h3><p>Redis中保存的key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常见的一种数据结构</p>
<p>不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题</p>
<ul>
<li>获取字符串长度需要通过运算</li>
<li>非二进制安全</li>
<li>不可修改</li>
</ul>
<p>Redis构建了一种新的字符串结构，称为<strong>简单动态字符串</strong>（Simple Dynamic String），简称SDS。</p>
<p>例如，执行如下命令:</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set name 虎哥</span><br></pre></td></tr></tbody></table></figure>

<p>那么Redis将会在底层创建两个SDS，其中一个是包含”name”的SDS，另一个是包含”虎哥”的SDS</p>
<p>Redis是C语言实现的，其中SDS是一个结构体，源码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> {</span></span><br><span class="line">  <span class="type">uint8_t</span> len; <span class="comment">/* buf已保存的字符串字节数，不包含结束标示 */</span></span><br><span class="line">  <span class="type">uint8_t</span> alloc; <span class="comment">/* buf申请的总的字节数，不包含结束标示 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> flags; <span class="comment">/* 不同SDS的头类型，用来控制SDS的头大小 */</span></span><br><span class="line">  <span class="type">char</span> buf[];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>SDS之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为”hi”的SDS：</p>
<table>
  <tbody><tr>
      <th>len: 2</th>
    <th>alloc: 2</th>
    <th>flags: 1</th>
    <th>h</th>
    <th>i</th>
    <th>\0</th>
  </tr>
</tbody></table>


<p>假如给SDS追加一段字符串”,Amy”，首先会申请新的内存空间：</p>
<ul>
<li>如果新字符串小于1M，则新空间为扩展后字符串长度的两倍+1</li>
<li>如果新字符串大于1M，则新空间为扩展后字符串长度+1M+1。称为<strong>内存预分配</strong></li>
</ul>
<table>
  <tbody><tr>
      <th>len: 6</th>
    <th>alloc: 12</th>
    <th>flags: 1</th>
    <th>h</th>
    <th>i</th>
    <th>,</th>
    <th>A</th>
    <th>m</th>
    <th>y</th>
    <th>\0</th>
    <th> </th>
    <th> </th>
    <th> </th>
  </tr>
</tbody></table>


<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ol>
<li>获取字符串长度的时间复杂度为O(1)</li>
<li>支持动态扩容</li>
<li>减少内存分配次数</li>
<li>二进制安全</li>
</ol>
<h3 id="IntSet"><a href="#IntSet" class="headerlink" title="IntSet"></a>IntSet</h3><p>IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变，有序等特征</p>
<p>结构如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> {</span></span><br><span class="line">  <span class="type">uint32_t</span> encoding; <span class="comment">/* 编码方式，支持存放16位、32位、64位整数 */</span></span><br><span class="line">  <span class="type">uint32_t</span> length; <span class="comment">/* 元素个数 */</span></span><br><span class="line">  <span class="type">int8_t</span> contents[]; <span class="comment">/* 整数数组，保存集合数据 */</span></span><br><span class="line">} intset;</span><br></pre></td></tr></tbody></table></figure>

<p>其中的encoding包含三种模式，表示存储的整数大小不同：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT16 (sizeof(int16_t)) <span class="comment">/* 2字节整数，范围类似java的short */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT32 (sizeof(int32_t)) <span class="comment">/* 4字节整数，范围类似java的int */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INTSET_ENC_INT64 (sizeof(int64_t)) <span class="comment">/* 8字节整数，范围类似java的long */</span></span></span><br></pre></td></tr></tbody></table></figure>

<p>为了方便查找，Redis会将intset中所有的整数按照升序一次保存在contents数组中，结构如图</p>
<table>
  <tbody><tr>
      <th>encoding: INTSET_ENC_INT16</th>
    <th>length: 3</th>
    <th>5</th>
    <th>10</th>
    <th>20</th>
  </tr>
</tbody></table>


<p>数组中每个数字都在int16_t的范围内，因此采用的编码方式为INTSET_ENC_INT16，每部分占用的字节大小为：</p>
<ul>
<li>encoding：4字节</li>
<li>length：4字节</li>
<li>contents：2字节*3=6字节</li>
</ul>
<p>假设有一个intset，元素为[5, 10, 20]，采用的编码是INTSET_ENC_INT16，则每个整数占2字节：</p>
<p>向其中添加一个数字：50000，这个数字超过了int16_t的范围，intset会自动<strong>升级</strong>编码方式到合适的大小</p>
<p>流程如下：</p>
<ol>
<li>升级编码为INTSET_ENC_INT32，每个整数占4字节，并按照新的编码方式及元素个数扩容数组</li>
<li>倒序依次将数组中的元素拷贝到扩容后的正确位置</li>
<li>将待添加的元素放入数组末尾</li>
<li>最后，将inset的encoding属性改为INTSET_ENC_INT32，将length属性改为4</li>
</ol>
<table>
  <tbody><tr>
      <th>encoding: INTSET_ENC_INT32</th>
    <th>length: 4</th>
    <th>5</th>
    <th>10</th>
    <th>20</th>
    <th>50000</th>
  </tr>
</tbody></table>


<p>Intset可以看做是特殊的整数数组，具备一些特点：</p>
<ol>
<li>Redis回确保Intset中的元素唯一、有序</li>
<li>具备类型升级机制，可以节省内存空间</li>
<li>底层采用二分查找方式来查询</li>
</ol>
<h3 id="Dict"><a href="#Dict" class="headerlink" title="Dict"></a>Dict</h3><p>键与值的映射关系是通过Dict来实现的。</p>
<p>Dict由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> {</span></span><br><span class="line">  <span class="comment">// entry数组</span></span><br><span class="line">  <span class="comment">// 数组中保存的是指向entry的指针</span></span><br><span class="line">  dictEntry **table;</span><br><span class="line">  <span class="comment">// 哈希表大小</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> size;</span><br><span class="line">  <span class="comment">// 哈希表大小的掩码，总等于size-1</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> sizemask;</span><br><span class="line">  <span class="comment">// entry个数</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> used;</span><br><span class="line">} dictht;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> {</span></span><br><span class="line">  <span class="type">void</span> *key; <span class="comment">// 键</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> {</span></span><br><span class="line">    <span class="type">void</span> *val;</span><br><span class="line">    <span class="type">uint64_t</span> u64;</span><br><span class="line">    <span class="type">int64_t</span> s64;</span><br><span class="line">    <span class="type">double</span> d;</span><br><span class="line">  } v; <span class="comment">// 值</span></span><br><span class="line">   <span class="comment">// 下一个Entry的指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">} dictEntry;</span><br></pre></td></tr></tbody></table></figure>

<p>当向Dict添加键值对时，Redis首先根据key计算出hash值(h)，然后利用h&amp;sizemask来计算元素应该存储到数组中的哪个索引位置</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> {</span></span><br><span class="line">  dictType *type; <span class="comment">// dict类型，内置不同的hash函数</span></span><br><span class="line">  <span class="type">void</span> *privdata; <span class="comment">// 私有数据，在做特殊的hash运算用</span></span><br><span class="line">  dictht ht[<span class="number">2</span>]; <span class="comment">// 一个Dict包含两个哈希表，其中一个是当前数据，另一个一般是空，rehash时使用</span></span><br><span class="line">  <span class="type">long</span> rehashidx; <span class="comment">// rehash的进度，-1表示未进行</span></span><br><span class="line">  <span class="type">int16_t</span> pauserehash <span class="comment">// rahash是否暂停，1则暂停，0则继续</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Dict的扩容"><a href="#Dict的扩容" class="headerlink" title="Dict的扩容"></a>Dict的扩容</h4><p>Dict中的HashTable就是数组结合单向链表的实现，当集合中元素较多时，必然导致hash冲突增多，链表过长，则查询效率会大幅降低</p>
<p>Dict在每次新增键值对时都会交叉<strong>负载因子</strong>（LoadFactor = used/size），满足以下两种情况时会触发哈希表扩容：</p>
<ul>
<li>哈希表的LoadFactor &gt;= 1，并且服务器没有执行BGSAVE或者BGREWRITEAOF等后台进程</li>
<li>哈希表的LoadFactor &gt; 5</li>
</ul>
<h4 id="Dict的收缩"><a href="#Dict的收缩" class="headerlink" title="Dict的收缩"></a>Dict的收缩</h4><p>Dict出了扩容以外，每次删除元素时，也会对负载因子做检查，当LoadFactor&lt;0.1时，会做哈希表收缩</p>
<h4 id="Dict的rehash"><a href="#Dict的rehash" class="headerlink" title="Dict的rehash"></a>Dict的rehash</h4><p>不论扩容还是收缩，必定会创建新的hash表，导致哈希表的size和sizemask变化，而key的查询与sizemask有关。因此必须对哈希表中的每一个key重新计算索引，插入新的哈希表，这个过程称为<strong>rehash</strong>。过程如下：</p>
<ol>
<li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：<ul>
<li>如果是扩容，则新size为第一个大于等于dict.ht[0].used+1的 $2^n$</li>
<li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的 $2^n$</li>
</ul>
</li>
<li>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</li>
<li>设置dict.rehashidx=0，标示开始rehash</li>
<li>将dict.ht[0]中的每一个dictEntry都rehash到dict.ht[1]</li>
<li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li>
</ol>
<p>Dict的rehash不是一次性完成的。因为如果Dict中包含数百万的entry，要在一次rehash完成，极有可能导致主线程阻塞。因此Dict的rehash是分多次、渐进式的完成，因此称为<strong>渐进式rehash</strong>。流程如下:</p>
<ol>
<li>计算新hash表的realeSize，值取决于当前要做的是扩容还是收缩：<ul>
<li>如果是扩容，则新size为第一个大于等于dict.ht[0].used+1的 $2^n$</li>
<li>如果是收缩，则新size为第一个大于等于dict.ht[0].used的 $2^n$</li>
</ul>
</li>
<li>按照新的realeSize申请内存空间，创建dictht，并赋值给dict.ht[1]</li>
<li>设置dict.rehashidx=0，标示开始rehash</li>
<li>每次执行新增、查询、修改、删除操作时，都检查一下dict.rehashidx是否大于-1，如果是则将dict.ht[0].table[rehashidx]的entry链表rehash到dict.ht[1]，并且将rehashidx++。直至dict.ht[0]的所有数据都rehash到dict.ht[1]</li>
<li>将dict.ht[1]赋值给dict.ht[0]，给dict.ht[1]初始化为空哈希表，释放原来的dict.ht[0]的内存</li>
<li>将rehashidx赋值为-1，代表rehash结束</li>
<li>在rehash过程中，新增操作，则直接写入ht[1]，查询、修改和删除则会在dict.ht[0]和dict.ht[1]依次查找并执行。这样可以确保ht[0]的数据只减不增，随着rehash最终为空</li>
</ol>
<h3 id="ZipList"><a href="#ZipList" class="headerlink" title="ZipList"></a>ZipList</h3><p>ZipList是一种特殊的“双端链表”，由一系列特殊编码的连续内存块组成。可以在任意一端进行压入/弹出操作，并且该操作的时间复杂度为O(1)</p>
<table>
  <tbody><tr>
      <th>zlbytes</th>
    <th>zltail</th>
    <th>zllen</th>
    <th>entry</th>
    <th>entry</th>
    <th>...</th>
    <th>entry</th>
    <th>zlend</th>
  </tr>
</tbody></table>


<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">类型</th>
<th align="center">长度</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">zlbytes</td>
<td align="center">uint32_t</td>
<td align="center">4字节</td>
<td align="center">记录整个压缩列表占用的内存字节数</td>
</tr>
<tr>
<td align="center">zltail</td>
<td align="center">uint32_t</td>
<td align="center">4字节</td>
<td align="center">记录压缩列表表尾节点距离压缩列表的起始地址有多少字节，通过这个偏移量，可以确定表尾结点的地址</td>
</tr>
<tr>
<td align="center">zllen</td>
<td align="center">uint32_t</td>
<td align="center">2字节</td>
<td align="center">记录了压缩列表包含的节点数量。最大值为UINT16_MAX(65534)，如果超过这个值，此处会记录为65535，但节点的真实数量需要遍历整个压缩列表才能计算得出</td>
</tr>
<tr>
<td align="center">entry</td>
<td align="center">列表节点</td>
<td align="center">不定</td>
<td align="center">压缩列表包含的各个节点，节点的长度由节点保存的内容决定</td>
</tr>
<tr>
<td align="center">zlend</td>
<td align="center">uint8_t</td>
<td align="center">1字节</td>
<td align="center">特殊值0xFF（二进制255），用于标记压缩列表的末端</td>
</tr>
</tbody></table>
<p>ZipList中的Entry不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16字节，浪费内存。而是采用如下结构：</p>
<table>
  <tbody><tr>
      <th>previous_entry_length</th>
    <th>encoding</th>
    <th>content</th>
  </tr>
</tbody></table>


<ul>
<li>previous_entry_length：前一节点的长度，占用1个或5个字节<ul>
<li>如果前一节点的长度小于254字节，则采用1个字节来保存这个长度值</li>
<li>如果前一节点的长度大于254字节，则采用5个字节来保存这个长度值，第一个字节为0xfe，后四个字节才是真实长度数据</li>
<li>encoding：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节</li>
<li>contents：负责保存节点的数据，可以使字符串或整数</li>
</ul>
</li>
</ul>
<p><strong>ZipList中所有存储长度的数值均采用小端字节序，即低位字节在前，高位字节在后</strong></p>
<h4 id="Encoding编码"><a href="#Encoding编码" class="headerlink" title="Encoding编码"></a>Encoding编码</h4><p>ZipListEntry中的encoding编码分为字符串和整数两种</p>
<ul>
<li>字符串：如果encoding是以“00”、“01”或者“10”开头，则证明content是字符串</li>
</ul>
<table>
<thead>
<tr>
<th align="center">编码</th>
<th align="center">编码长度</th>
<th align="center">字符串大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">|00pppppp|</td>
<td align="center">1 bytes</td>
<td align="center">&lt;= 63 bytes</td>
</tr>
<tr>
<td align="center">|01pppppp|qqqqqqqq|</td>
<td align="center">2 bytes</td>
<td align="center">&lt;= 16383 bytes</td>
</tr>
<tr>
<td align="center">|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</td>
<td align="center">5 bytes</td>
<td align="center">&lt;= 4294967295 bytes</td>
</tr>
</tbody></table>
<ul>
<li>整数：如果encoding是以“11”开始，则证明content是整数，且encoding固定只占用1个字节</li>
</ul>
<table>
<thead>
<tr>
<th align="center">编码</th>
<th align="center">编码长度</th>
<th align="center">整数类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">11000000</td>
<td align="center">1</td>
<td align="center">int16_t (2 bytes)</td>
</tr>
<tr>
<td align="center">11010000</td>
<td align="center">1</td>
<td align="center">int32_t (4 bytes)</td>
</tr>
<tr>
<td align="center">11100000</td>
<td align="center">1</td>
<td align="center">int64_t (8 bytes)</td>
</tr>
<tr>
<td align="center">11110000</td>
<td align="center">1</td>
<td align="center">24位有符整数 (3 bytes)</td>
</tr>
<tr>
<td align="center">11111110</td>
<td align="center">1</td>
<td align="center">8位有符整数 (1 bytes)</td>
</tr>
<tr>
<td align="center">1111xxxx</td>
<td align="center">1</td>
<td align="center">直接在xxxx位置保存数值，范围从0001~1101，减1后结果位实际值</td>
</tr>
</tbody></table>
<p><strong>ZipList的连锁更新问题</strong></p>
<h3 id="QuickList"><a href="#QuickList" class="headerlink" title="QuickList"></a>QuickList</h3><p>ZipList虽然节省内存，但申请内存必须是连续空间，如果内存占用较多，申请内存效率很低，为了缓解这个问题，必须限制ZipList的长度和entry大小</p>
<p>存储大量数据，超出了ZipList最佳上限，可以创建多个ZipList来分片存储数据</p>
<p>数据拆分后比较分散，不方便管理和查找，Redis在3.2版本引入了新的数据结构QuickList，它是一个双端链表，只不过链表中的每个节点都是一个ZipList</p>
<p>为了避免QuickList中的每个ZipList中entry过多，Redis提供了一个配置项：<strong>list-max-ziplist-size</strong>来限制</p>
<ul>
<li>如果值为正，则代表ZipList的允许的entry个数的最大值</li>
<li>如果值为负，则代表ZipList的最大内存大小，分5种情况：<ol>
<li>-1：每个ZipList的内存占用不能超过4kb</li>
<li>-2：每个ZipList的内存占用不能超过8kb</li>
<li>-3：每个ZipList的内存占用不能超过16kb</li>
<li>-4：每个ZipList的内存占用不能超过32kb</li>
<li>-5：每个ZipList的内存占用不能超过64kb</li>
</ol>
</li>
</ul>
<p>其默认值为-2</p>
<p>除了控制ZipList的大小，QuickList还可以对节点的ZipList做压缩。通过配置项lsit-compress-depth来控制。因为链表一般都是从首尾访问较多，所以首尾是不压缩的。这个参数是控制首尾不压缩的节点个数：</p>
<ul>
<li>0：特殊值，代表不压缩</li>
<li>1：标示QuickList的首尾各有1个节点不压缩，中间节点压缩</li>
<li>2：标示QuickList的首尾各有2个节点不压缩，中间节点压缩</li>
<li>以此类推</li>
</ul>
<p>默认值：0</p>
<h3 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h3><p>SkipList（跳表）首先是链表，但与传统链表相比有几点差异</p>
<ul>
<li>元素按照升序排列存储</li>
<li>节点可能包含多个指针，指针跨度不同</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> {</span></span><br><span class="line">  <span class="comment">// 头尾节点指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">head</span>, *<span class="title">tail</span>;</span></span><br><span class="line">  <span class="comment">// 节点数量</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> length;</span><br><span class="line">  <span class="comment">// 最大的索引层级，默认是1</span></span><br><span class="line">  <span class="type">int</span> level;</span><br><span class="line">} zskiplist;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> {</span></span><br><span class="line">  sds ele; <span class="comment">// 节点存储的值</span></span><br><span class="line">  <span class="type">double</span> score; <span class="comment">// 节点分数，排序，查找用</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>:</span> <span class="comment">// 前一个节点指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> {</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span> <span class="comment">// 下一个节点指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> span; <span class="comment">// 索引跨度</span></span><br><span class="line">  } level[]; <span class="comment">// 多级索引数组</span></span><br><span class="line">} zskiplistNode;</span><br></pre></td></tr></tbody></table></figure>

<h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul>
<li>跳表是一个双向链表，每个节点都包含score和ele值</li>
<li>节点按照score值排序，score值一样则按照ele字典排序</li>
<li>每个节点都可以包含多层指针，层数是1到32之间的随机数</li>
<li>不同层指针到下一个节点的跨度不同，层级越高，跨度越大</li>
<li>增删改查效率与红黑树基本一致，实现更加简单</li>
</ul>
<h3 id="RedisObject"><a href="#RedisObject" class="headerlink" title="RedisObject"></a>RedisObject</h3><p>Redis中的任意数据类型的键和值都会被封装为一个RedisObject，也叫做Redis对象，源码如下：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> {</span></span><br><span class="line">  <span class="type">unsigned</span> type:<span class="number">4</span>; <span class="comment">// 对象类型，分别是string、hash、list、set和zset，占4个bit位</span></span><br><span class="line">  <span class="type">unsigned</span> encoding:<span class="number">4</span>; <span class="comment">// 底层编码方式，共有11种，占4个bit位</span></span><br><span class="line">  <span class="type">unsigned</span> lru:LRU_BITS; <span class="comment">//LRU_BITS为24 lur表示该对象最后一次被访问的时间，其占用24个bit位。便于判断空闲时间太久的key</span></span><br><span class="line">  <span class="type">int</span> refcount; <span class="comment">// 对象引用计数器，计数器为0则说明无人引用，可以被回收</span></span><br><span class="line">  <span class="type">void</span> *ptr; <span class="comment">// 指针，指向存放实际数据的空间</span></span><br><span class="line">} robj;</span><br></pre></td></tr></tbody></table></figure>

<p>Redis会根据存储的数据类型不同，选择不同的编码方式。每种数据类型的使用的编码方式如下：</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">编码方式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OBJ_STRING</td>
<td align="center">int、embstr、raw</td>
</tr>
<tr>
<td align="center">OBJ_LIST</td>
<td align="center">LinkedList和ZipList（3.2以前）、QuickList（3.2以后）</td>
</tr>
<tr>
<td align="center">OBJ_SET</td>
<td align="center">intset、HT</td>
</tr>
<tr>
<td align="center">OBJ_ZSET</td>
<td align="center">ZipLsit、HT、SkipList</td>
</tr>
<tr>
<td align="center">OBJ_HASH</td>
<td align="center">ZipList、HT</td>
</tr>
</tbody></table>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String是Redis最常见的数据存储类型</p>
<ul>
<li><p>其基本编码方式是<strong>RAW</strong>，基于简单动态字符串（SDS）实现，存储上限为512mb</p>
</li>
<li><p>如果存的的SDS长度小于44字节，则会采用EMBSTR编码，此时object head与SDS是一段连续空间。申请内存时只需要调用一次内存分配函数，效率更高</p>
</li>
<li><p>如果存储的字符串是整数值，并且大小在LONG_MAX范围内，则会采用<strong>INT</strong>编码：直接将数据保存在RedisObject的ptr指针（刚好8字节），不再需要SDS</p>
</li>
</ul>
<img src="/2023/09/18/redis/Stringcunchujiegou.png" alt="Stringcunchujiegou" style="zoom:50%;">

<h4 id="List"><a href="#List" class="headerlink" title="List"></a>List</h4><p>Redis的List类型可以从首、尾操作列表中的元素</p>
<p>Redis统一采用QuickList来实现List</p>
<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set是Redis中的单列集合，满足下列特点：</p>
<ul>
<li><p>不保证有序性</p>
</li>
<li><p>保证元素唯一（可以判断元素是否存在）</p>
</li>
<li><p>求交集、并集、差集</p>
</li>
<li><p>Set使用HashTable存储，也就是Redis中的Dict，不过Dict是双列集合（可以存键、值对）</p>
</li>
</ul>
<p>Set是Redis中的集合，不一定保证元素有序，可以满足元素唯一、查询效率要就极高</p>
<ul>
<li>为了查询效率和唯一性，set采用HT编码（Dict）。Dict中的key用来存储元素，value统一为null</li>
<li>当存储的所有数据都是整数，而且元素数量不超过set-max-intset-entries时，Set会采用IntSet编码，以节省内存</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">robj *<span class="title function_">setTypeCreate</span><span class="params">(sds value)</span> {</span><br><span class="line">  <span class="comment">// 判断value是否是数值类型 long long</span></span><br><span class="line">  <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value, <span class="literal">NULL</span>) == C_OK)</span><br><span class="line">    <span class="comment">// 如果是数值类型，则采用IntSet编码</span></span><br><span class="line">    <span class="keyword">return</span> createIntsetObject();</span><br><span class="line">  <span class="comment">// 否则采用默认编码，也就是HT</span></span><br><span class="line">  <span class="keyword">return</span> createSetObject();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">robj *<span class="title function_">createIntsetObject</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">  <span class="comment">// 初始化INTSET并申请内存空间</span></span><br><span class="line">  intset *is = intsetNew();</span><br><span class="line">  <span class="comment">// 创建RedisObject</span></span><br><span class="line">  robj *o = createObject(OBJ_SET, is);</span><br><span class="line">  <span class="comment">// 指定编码为INTSET</span></span><br><span class="line">  o -&gt; encoding = OBJ_ENCODING_INTSET;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">robj *<span class="title function_">createSetObject</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">  <span class="comment">// 初始化Dict类型，并申请内存</span></span><br><span class="line">  dict *d = dictCreate(&amp;setDictType, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 创建RedisObject</span></span><br><span class="line">  robj *o = createObject(OBJ_SET, d);</span><br><span class="line">  <span class="comment">// 设置encoding为HT</span></span><br><span class="line">  o -&gt; encoding = OBJ_ENCODING_HT;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Set会根据数据类型更改编码。如如果Set原本编码是IntSet，此时传入float，则Set会更改编码为HT编码<br>set-max-intset-entries的默认值为512</p>
<p><img src="/2023/09/18/redis/SetStruct.png" alt="SetStruct"></p>
<h4 id="ZSet"><a href="#ZSet" class="headerlink" title="ZSet"></a>ZSet</h4><p>ZSet也就是SortedSet，其中每一个元素都需要指定一个score值和member值</p>
<ul>
<li>可以根据score值排序</li>
<li>member必须唯一</li>
<li>可以根据member查询分数</li>
</ul>
<p>ZSet底层数据结构必须满足<strong>键值存储</strong>、<strong>键必须唯一</strong>、<strong>可排序</strong>这几个需求。</p>
<ul>
<li>SkipList：可以排序，并且同时存储score和ele值（member）</li>
<li>HT（Dict）：可以键值存储，并且可以根据key获取value（无法排序）</li>
</ul>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zset结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> {</span></span><br><span class="line">  <span class="comment">// Dict指针</span></span><br><span class="line">  dict *dict;</span><br><span class="line">  <span class="comment">// SkipList指针</span></span><br><span class="line">  zskiplist *zsl;</span><br><span class="line">} zset;</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">robj *<span class="title function_">createZsetObject</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">  zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">  robj *o;</span><br><span class="line">  <span class="comment">// 创建Dict</span></span><br><span class="line">  zs -&gt; dict = dictCreate(&amp;zsetDictType, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="comment">// 创建SkipList</span></span><br><span class="line">  zs -&gt; zsl = zslCreate();</span><br><span class="line">  o = createObject(OBJ_ZSET, zs);</span><br><span class="line">  o -&gt; encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>第一种方式：HT和SkipList组合使用，速度快，但空间占用大</li>
</ul>
<p><img src="/2023/09/18/redis/ZSetStruct.png" alt="ZSetStruct"></p>
<ul>
<li>第二种方式：使用ZipList代替SkipList存储，节省内存空间</li>
</ul>
<p>需要同时满足两个条件：</p>
<ol>
<li>元素数量小于zset_max_ziplist_entries，默认值为128</li>
<li>每个元素都小于zset_max_ziplist_value自己诶，默认值64</li>
</ol>
<p>与Set类似，当不满足条件会触发编码转换</p>
<p>ziplist本身没有排序功能，而且没有键值对概念，因此需要有zset通过编码实现：</p>
<ul>
<li>ZipList是连续内存，因此score和elemet是紧凑在一起的两个entry，element在前，score在后</li>
<li>score越小越接近队首，score越大越接近队尾，按照score升序排列</li>
</ul>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash结构与Redis中的ZSet非常类似：</p>
<ul>
<li>都是键值存储</li>
<li>都需求根据键获取值</li>
<li>键必须唯一</li>
</ul>
<p>区别如下：</p>
<ul>
<li>ZSet的键是member，值是score；hash的键和值都是任意键</li>
<li>ZSet要根据score排序；hash无需排序</li>
</ul>
<p>Hash底层采用的编码与ZSet基本一致，只需要把排序有关的SkipList去掉即可</p>
<ul>
<li>Hash结构默认采用ZipList编码，以节省内存。ZipList中相邻的两个entry分别保存field和value</li>
<li>当数据量较大时，Hash结构会转为HT编码，也就是Dict，触发的条件有两个：<ul>
<li>ZipList中的元素数量超过了hash-max-ziplist-entries（默认512）</li>
<li>ZipList中的任意entry大小超过了hash-max-ziplist-value（默认64字节）</li>
</ul>
</li>
</ul>
<p><img src="/2023/09/18/redis/HashStruct.png" alt="HashStruct"></p>
<h2 id="Redis网络模型"><a href="#Redis网络模型" class="headerlink" title="Redis网络模型"></a>Redis网络模型</h2><h3 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h3><p>为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：</p>
<ul>
<li>进程的寻址空间会划分为两部分：<strong>内核空间</strong>、<strong>用户空间</strong></li>
<li><strong>用户空间</strong>只能执行受限的命令（Ring3），而且不能直接调用系统资源，必须通过内核提供的接口来访问</li>
<li><strong>内核空间</strong>可以执行特权命令（Ring0），调用一切系统资源</li>
</ul>
<p>Linux系统为了提高IO效率，会在用户控件和内核空间都加入缓冲区：</p>
<ul>
<li>写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备</li>
<li>读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区</li>
</ul>
<p><img src="/2023/09/18/redis/LinuxRead.png" alt="LinuxRead"></p>
<h3 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h3><p>阻塞IO，两个阶段都必须阻塞等待：</p>
<p><img src="/2023/09/18/redis/blockIO.png" alt="blockIO"></p>
<h3 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h3><p>非阻塞IO的recfrom操作会立即返回结果而不是阻塞用户进程</p>
<p><img src="/2023/09/18/redis/NoBlockIO.png" alt="NoBlockIO"></p>
<p>非阻塞IO模型中，用户进程在第一阶段是非阻塞的，第二阶段是阻塞状态。虽然是非阻塞，但性能没有得到提高。而且忙等机制会导致CPU空转，CPU使用率暴增</p>
<h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p><strong>文件描述符</strong>（File Descriptor）：简称FD，是一个从0开始递增的无符号整数，用来关联Linux中的一个文件。在Linux中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包裹网络套接字（Socket）</p>
<p><strong>IO多路复用</strong>：利用单个线程来监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源</p>
<p><img src="/Users/yucan/Desktop/redis/IOEpoll.png" alt="IOEpoll"></p>
<p>监听FD的方式、通知的方式有多种实现，常见的有:</p>
<ul>
<li>select</li>
<li>poll</li>
<li>epoll</li>
</ul>
<p>差异：</p>
<ul>
<li>select和poll只会通知用户进程有FD就绪，但不确定具体是哪个FD，需要用户进程逐个遍历FD来确认</li>
<li>epoll则会在通知用户进程FD就绪的同时，把已就绪的FD写入用户空间</li>
</ul>
<h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p><strong>select</strong>是Linux中最早的I/O多路复用实现方案：</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类型别名 __fd_mask，本质是 long int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">int</span> __fd_mask;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fd_set 记录要监听的fd集合，及其对应状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">  <span class="comment">// fds_bits是long类型数组，长度为 1024/32 = 32</span></span><br><span class="line">  <span class="comment">// 共1024个bit位，每个bit位代表一个fd，0代表未就绪，1代表就绪</span></span><br><span class="line">  __fd_mask fds_bits[__FD_SETSIZE /__NFDBITS];</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">} fd_set;</span><br><span class="line"></span><br><span class="line"><span class="comment">// select函数，用来监听多个fd的集合</span></span><br><span class="line"><span class="type">int</span> select {</span><br><span class="line">  <span class="type">int</span> nfds, <span class="comment">// 要监听的fd_set的最大 fd + 1</span></span><br><span class="line">  fd_set *readfds, <span class="comment">// 要监听读事件的fd集合</span></span><br><span class="line">  fd_set *writefds, <span class="comment">// 要监听写事件的fd集合</span></span><br><span class="line">  fd_set *exceptfds, <span class="comment">// 要监听异常事件的fd集合</span></span><br><span class="line">  <span class="comment">// 超时时间，null-永不超时；0-不阻塞等待；大于0-固定等待时间</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">timeout</span></span></span><br><span class="line"><span class="class">};</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2023/09/18/redis/SelectSequence.png" alt="SelectSequence"></p>
<p>存在的问题：</p>
<ul>
<li>需要将整个fd_set从用户空间拷贝到内核空间，selec结束还要再次拷贝回用户空间</li>
<li>select无法得知具体是哪个fd就绪，需要遍历整个fd_set</li>
<li>fd_set监听的fd数量不能超过1024</li>
</ul>
<h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p><strong>poll</strong>模式对select模式做了简单改进，但性能提升不明显</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pollfd中的时间类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLIN <span class="comment">// 可读事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLOUT <span class="comment">// 可写事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLERR <span class="comment">// 错误事件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> POLLNVAL <span class="comment">// fd未打开</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pollfd结构</span></span><br><span class="line">strcut pollfd {</span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// 要监听的fd</span></span><br><span class="line">  <span class="type">short</span> <span class="type">int</span> events; <span class="comment">// 要监听的事件类型：读、写、异常</span></span><br><span class="line">  <span class="type">short</span> <span class="type">int</span> revetns; <span class="comment">// 实际发生的事件类型</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// poll函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">poll</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="keyword">struct</span> pollfd *fds, <span class="comment">// pollfd数组，可以自定义大小</span></span></span><br><span class="line"><span class="params">  <span class="type">ndfd_t</span> nfds <span class="comment">// 数组元素个数</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></tbody></table></figure>

<p>IO流程：</p>
<ol>
<li>创建pollfd数组，向其中添加关注的fd信息，数组大小自定义</li>
<li>调用poll函数，将pollfd数组拷贝到内核空间，转链表存储，无上限</li>
<li>内核遍历fd，判断是否就绪</li>
<li>数据就绪或超时后，拷贝pollfd数组到用户空间，返回就绪fd数量n</li>
<li>用户进程判断n是否大于0</li>
<li>大于0则遍历pollfd数组，找到就绪的fd</li>
</ol>
<p>与select对比：</p>
<ul>
<li>select模式的fd_set大小固定为1024，而pollfd在内核中采用链表，理论上无上限</li>
<li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li>
</ul>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>epoll模式是对select和poll的改进，它提供了三个函数</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">strcut eventpoll {</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span> <span class="comment">// 一颗红黑树，记录要监听的FD</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdlsit</span>;</span> <span class="comment">// 一个链表，记录就绪的FD</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.会在内核创建eventpoll结构体，返回对应的句柄epfd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.将一个FD添加到epoll的红黑树中，并设置ep_poll_callback</span></span><br><span class="line"><span class="comment">// callback触发时，就把对应的FD加入到rdlist这个就绪列表中</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">int</span> epfd <span class="comment">// epoll实例的句柄</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> op, <span class="comment">// 要执行的操作，包括: ADD、MOD、DEL</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> fd, <span class="comment">// 要监听的FD</span></span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> epoll_event *event <span class="comment">// 要监听的事件类型：读、写、异常等</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">// 3.检查rdlist列表是否为空，不为空则返回就绪的FD的数量</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_wait</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">int</span> epfd, <span class="comment">// eventpoll实例的句柄</span></span></span><br><span class="line"><span class="params">  <span class="keyword">struct</span> epoll_event *events, <span class="comment">// 空event数组，用于接收就绪的FD</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> maxevents, <span class="comment">// events数组的最大长度</span></span></span><br><span class="line"><span class="params">  <span class="type">int</span> timeout <span class="comment">// 超时时间，-1用不超时；0不阻塞；大于0为阻塞时间</span></span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2023/09/18/redis/epollSequence.png" alt="epollSequence"></p>
<p>当FD有数据可读时，调用epoll_wait可以得到通知，但事件通知的模式有两种：</p>
<ul>
<li>levelTriggered：简称LT。当FD有数据可读时，会重复通知多次，直至数据处理完成。是Epoll的默认模式</li>
<li>EdgeTriggered：简称ET。当FD有数据可读时，只会被通知一次，不管数据是否处理完成</li>
</ul>
<p>ET模式避免了LT模式可能出现的惊群现象，ET模式最好结合非阻塞IO读取FD数据，相比LT会复杂一些</p>
<h4 id="信号驱动IO"><a href="#信号驱动IO" class="headerlink" title="信号驱动IO"></a>信号驱动IO</h4><p><strong>信号驱动IO</strong>是与内核建立SIGIO的信号关联并设置回调，当内核有FD就绪时，会发出SIGIO信号通知用户，期间用户应用可以执行其他业务，无需阻塞等待。</p>
<p>缺陷：</p>
<ul>
<li>当有大量IO操作时，信号较多，SIGIO处理函数不能即时处理可能导致信号队列溢出</li>
<li>而且内核空间与用户空间的频繁信号交互性能也较低</li>
</ul>
<h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p><strong>异步IO</strong>的整个过程都是非阻塞的，用户进程调用完异步API后就可以去做其他事情，内核等待数据就绪并拷贝到用户空间后才会递交信号，通知用户进程</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis是单线程还是多线程</p>
<ul>
<li>如果仅仅是Redis的核心业务部分（命令处理），是单线程</li>
<li>如果是整个Redis，那么是多线程</li>
</ul>
<p>Redis采用单线程的原因：</p>
<ul>
<li>抛开持久化不谈，Redis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，因此多线程并不会带来巨大的性能提升</li>
<li>多线程会导致过多的上下文切换，带来不必要的开销</li>
<li>引入多线程会面临线程安全问题，必须要引入线程锁这样的安全手段，实现复杂度增高，而且性能也会大打折扣</li>
</ul>
<p>Redis通过IO多路复用来提高网络性能，并且支持各种不同的多路复用实现，并且将这些实现进行封装，提供了统一的高性能事件库API库AE</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.c</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(</span></span><br><span class="line"><span class="params">	<span class="type">int</span> argc,</span></span><br><span class="line"><span class="params">  <span class="type">char</span> **argv</span></span><br><span class="line"><span class="params">)</span> {</span><br><span class="line">  <span class="comment">// 初始化服务</span></span><br><span class="line">  initServer();</span><br><span class="line">  <span class="comment">// 开始监听时间循环</span></span><br><span class="line">  aeMain(server.el);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">initServer</span><span class="params">(<span class="type">void</span>)</span> {</span><br><span class="line">  <span class="comment">// 内部调用 aeApiCreate(eventLoop)，类似于epoll_create</span></span><br><span class="line">  server.el = aeCreateEventLoop(</span><br><span class="line">  								server.maxclients + CONFIG_FDSET_INCR);</span><br><span class="line">  <span class="comment">// 监听TCP端口，创建ServerSocket，并得到FD</span></span><br><span class="line">  listenToPort(server.port, &amp;server.ipfd);</span><br><span class="line">  <span class="comment">// 注册 连接处理器，内部会调用aeApiAddevent(&amp;server.ipfd)监听FD</span></span><br><span class="line">  createSocketAcceptHandler(&amp;server.ipfd, acceptTcpHandler);</span><br><span class="line">  <span class="comment">// 注册 ae_api_poll前的处理器</span></span><br><span class="line">  aeSetBeforeSleepProc(server.el, beforeSleep);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> {</span><br><span class="line">  eventLoop -&gt; stop = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 循环监听事件</span></span><br><span class="line">  <span class="keyword">while</span> (!eventLoop-&gt;stop) {</span><br><span class="line">    aeProcessEvents(</span><br><span class="line">    	eventLoop,</span><br><span class="line">    	AE_ALL_EVENTS | AE_CALL_BEFORE_SLEEP | AE_CALL_AFTER_SLEEP);</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">aeProcessEvents</span><span class="params">(</span></span><br><span class="line"><span class="params">	aeEventLoop *eventLoop,</span></span><br><span class="line"><span class="params">  <span class="type">int</span> flags</span></span><br><span class="line"><span class="params">)</span> {</span><br><span class="line">  <span class="comment">// 调用前置处理器</span></span><br><span class="line">  eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line">  <span class="comment">// 等待FD就绪，类似epoll_wait</span></span><br><span class="line">  numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line">  <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) {</span><br><span class="line">    <span class="comment">// 遍历处理就绪的FD，调用对应的处理器</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据读处理器</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">acceptTcpHandler</span><span class="params">(...)</span> {</span><br><span class="line">  <span class="comment">// 接收socket链接，获取FD</span></span><br><span class="line">  fd = accept(s, sa, len);</span><br><span class="line">  <span class="comment">// 创建connection，关联fd</span></span><br><span class="line">  connection *conn = connCreateSocket();</span><br><span class="line">  conn.fd = fd;</span><br><span class="line">  <span class="comment">// 内部调用aeApiAddEvent(fd, READABLE),</span></span><br><span class="line">  <span class="comment">// 监听socket的FD读事件，并绑定读处理器readQueryFromClient</span></span><br><span class="line">  connSetReadHandler(conn, readQueryFromClient);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">beforeSleep</span><span class="params">(<span class="keyword">struct</span> aeEventLoop *eventLop)</span> {</span><br><span class="line">  <span class="comment">// 定义迭代器，指向serer.clients_pending_write-&gt;head;</span></span><br><span class="line">  listIter li;</span><br><span class="line">  li-&gt;next = server.clients_pending_write-&gt;head;</span><br><span class="line">  li-&gt;direction = AL_START_HEAD;</span><br><span class="line">  <span class="comment">// 循环遍历待写出的client</span></span><br><span class="line">  <span class="keyword">while</span> ((ln = listNext(&amp;li))) {</span><br><span class="line">    <span class="comment">// 内部调用aeApiAddEvent(fd, WRITEABLE), 监听socket的FD读事件</span></span><br><span class="line">    <span class="comment">// 并且绑定写处理器sendReplyToClient，可以把响应写到客户端socket</span></span><br><span class="line">    connSetWriteHandlerWithBarrier(c-&gt;conn, sendReplyToClient, ae_barrier)</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2023/09/18/redis/RedisNetStruct.png" alt="RedisNetStruc"></p>
<h4 id="Redis通信协议"><a href="#Redis通信协议" class="headerlink" title="Redis通信协议"></a>Redis通信协议</h4><p>Redis是一个C/S架构的软件，通信一般分为两步（不包括pipeline和PubSub）：</p>
<ol>
<li>客户端（client）向服务端（server）发送一条命令</li>
<li>服务端解析并执行命令，返回响应结果给 客户端</li>
</ol>
<p>客户端发送命令的格式、服务端响应结果的格式需要有一个规范，这个规范就是通信协议</p>
<p>Redis一般采用<strong>RESP</strong>协议</p>
<h5 id="RESP"><a href="#RESP" class="headerlink" title="RESP"></a>RESP</h5><h6 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h6><p>RESP中，通过首字节的字符来区分不同数据类型，常用的数据类型包括5种：</p>
<ul>
<li><p>单行字符串：首字节是’+’，后面跟上单行字符串，以CRLF(“\r\n”)结尾</p>
</li>
<li><p>错误（Errors）：首字节是’-‘，与单行字符串格式一样，只是字符串是异常信息</p>
</li>
<li><p>数值：首字节是”:”，后面跟上数字格式的字符串，以CRLF结尾</p>
</li>
<li><p>多行字符串：首字节是’$’，标示二进制安全的字符串，最大支持512MB</p>
<ul>
<li>如果大小为0，则表示空字符串：”$0\r\r\n”</li>
<li>如果大小为-1，则表示不存在：”$-1\r\n”</li>
</ul>
</li>
<li><p>数组：首字节是’*’，后面跟上数组元素个数，再跟上元素，元素数据类型不限</p>
</li>
</ul>
<h2 id="Redis内存策略"><a href="#Redis内存策略" class="headerlink" title="Redis内存策略"></a>Redis内存策略</h2><h3 id="Redis内存回收"><a href="#Redis内存回收" class="headerlink" title="Redis内存回收"></a>Redis内存回收</h3><p>单节点Redis的内存大小不宜过大，会影响持久化或主从同步性能</p>
<p>可以通过修改配置文件来设置Redis的最大内存</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maxmemory 1gb</span><br></pre></td></tr></tbody></table></figure>

<p>当内存使用达到上限时，就无法存储更多数据了</p>
<h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><p>通过expire命令给Redis的key设置TTL（存活时间）</p>
<p>当key的TTL到期以后，再次访问name返回的null，说明这个key已经不存在了，对应的内存也得到释放，从而起到内存回收的目的</p>
<h4 id="过期策略-DB结构"><a href="#过期策略-DB结构" class="headerlink" title="过期策略-DB结构"></a>过期策略-DB结构</h4><p>Redis本身是一个典型的key-value内存存储数据库，因此所有的key、value都保存在Dict结构中。不过在database结构体中，由两个Dict：一个用来记录key-value；另一个用来记录key-TTL</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> {</span></span><br><span class="line">  dict *dict; <span class="comment">// 存放所有key及value的地方，也被称为keyspace</span></span><br><span class="line">  dict *expires; <span class="comment">// 存放每一个key及其对应的TTL存活时间，只包含设置了TTL的key</span></span><br><span class="line">  dict *blocking_keys; </span><br><span class="line">  dict *ready_keys; </span><br><span class="line">  dict *watched_keys; </span><br><span class="line">  <span class="type">int</span> id; </span><br><span class="line">  <span class="type">long</span> <span class="type">long</span> avg_ttl; <span class="comment">// 记录平均TTL时长</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> expires_cursor; </span><br><span class="line">  <span class="built_in">list</span> *defrag_later; <span class="comment">// 等待碎片整理的key列表</span></span><br><span class="line">} redisDb;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/2023/09/18/redis/RedisDBStruct.png" alt="RedisDBStruct"></p>
<h4 id="过期策略-惰性删除"><a href="#过期策略-惰性删除" class="headerlink" title="过期策略-惰性删除"></a>过期策略-惰性删除</h4><p><strong>惰性删除</strong>：顾名思义并不是在TTL到期后就立刻删除，而是在访问一个key的时候，检查该key的存活时间，如果已经过期才执行删除</p>
<h4 id="过期策略-周期删除"><a href="#过期策略-周期删除" class="headerlink" title="过期策略-周期删除"></a>过期策略-周期删除</h4><p><strong>周期删除</strong>：通过一个定时任务，周期性的<strong>抽样部分过期的key</strong>，然后执行删除。执行周期由两种：</p>
<ul>
<li>Redis会设置一个定时任务serverCron()，按照server.hz的频率来执行过期key清理，模式为SLOW</li>
<li>Redis的每个事件循环前会调用beforeSleep()函数，执行过期key清理，模式为FAST</li>
</ul>
<p>SLOW模式规则：</p>
<ol>
<li>执行频率受到server.hz影响，默认为10，即每秒执行10次，每个执行周期100ms</li>
<li>执行清理耗时不超过一次执行周期的25%</li>
<li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li>
<li>如果没达到时间上限（25ms）并且过期key比例大于10%，在进行一次抽样，否则结束</li>
</ol>
<p>FAST模式规则：</p>
<ol>
<li>执行频率受beforeSleep()调用频率影响，但两次FAST模式间隔不低于2ms</li>
<li>执行清理耗时不超过1ms</li>
<li>逐个遍历db，逐个遍历db中的bucket，抽取20个key判断是否过期</li>
<li>如果没达到时间上限（1ms）并且过期key比例大于10%，在进行一次抽样，否则结束</li>
</ol>
<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p><strong>内存淘汰</strong>：当Redis内存使用达到设置的阈值时，Redis主动挑选<strong>部分key</strong>删除以释放更多内存</p>
<p>Redis支持8种不同策略来选择要删除的key：</p>
<ul>
<li>noeviction：不淘汰任何key，但是内存满了不允许写入新数据，默认就是这种策略</li>
<li>volatile-ttl：对设置了ttl的key，比较key的剩余TTL值，TTL越小越先被淘汰</li>
<li>allkeys-random：对全体key，随机进行淘汰。也就是直接从db-&gt;dict中随机选择</li>
<li>volatile-random：对设置了TTL的key，随机进行淘汰。也就是从db-&gt;expires中随机挑选</li>
<li>allkeys-lru：对全体key，基于LRU算法进行淘汰</li>
<li>volatile-lru：对设置了TTL的key，基于LRU算法进行淘汰</li>
<li>allkeys-lfu：对全体key，基于LFU算法进行淘汰</li>
<li>volatile-lfu：对设置了TTL的key，基于LFI算法进行淘汰</li>
</ul>
<p><strong>LRU（Least Recently Used）</strong>，最少最近使用，用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高</p>
<p><strong>LFU （Least Frequently Used）</strong>，最少频率使用，会统计每个key的访问频率，值越小淘汰优先级越高</p>
<p>LFU的访问次数之所以叫做<strong>逻辑访问次数</strong>，是因为并不是每次key被访问都计数，而是通过运算：</p>
<ol>
<li>生成0~1之间的随机数R</li>
<li>计算1/(旧次数*lfu_log_factor+1)，记录为P，lfu_log_factor默认为10</li>
<li>如果R&lt;P，则计数器+1，且最大不超过255</li>
<li>访问次数会随着时间衰减，距离上一次访问时间每隔lfu_decay_time分钟（默认1），计数器-1</li>
</ol>
<p><img src="/2023/09/18/redis/expireMethod.png" alt="expireMethod"></p>
</body></html>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaWeb/" rel="tag"># JavaWeb</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/09/14/dataStruct/" rel="prev" title="dataStruct">
      <i class="fa fa-chevron-left"></i> dataStruct
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/18/JUC/" rel="next" title="JUC">
      JUC <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">Redis基础使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NoSQL%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">NoSQL特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">Redis特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">Redis数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">1.4.</span> <span class="nav-text">Redis通用命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.</span> <span class="nav-text">String类型命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#key%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.</span> <span class="nav-text">key的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4"><span class="nav-number">1.7.</span> <span class="nav-text">Hash类型命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.8.</span> <span class="nav-text">List类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.9.</span> <span class="nav-text">Set类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SortedSet%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.10.</span> <span class="nav-text">SortedSet类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Jedis"><span class="nav-number">2.</span> <span class="nav-text">Jedis</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringDataRedis"><span class="nav-number">3.</span> <span class="nav-text">SpringDataRedis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringDataRedis%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">SpringDataRedis快速使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="nav-number">3.1.1.</span> <span class="nav-text">引入依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">3.1.2.</span> <span class="nav-text">配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5RedisTemplate"><span class="nav-number">3.1.3.</span> <span class="nav-text">注入RedisTemplate</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringDataRedis%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">SpringDataRedis的序列化方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E6%88%98"><span class="nav-number">4.</span> <span class="nav-text">实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Session%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="nav-number">4.1.</span> <span class="nav-text">Session实现用户短信登录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">4.2.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="nav-number">4.2.1.</span> <span class="nav-text">缓存的简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0Redis%E7%BC%93%E5%AD%98"><span class="nav-number">4.2.2.</span> <span class="nav-text">添加Redis缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">4.2.3.</span> <span class="nav-text">缓存更新策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">4.2.4.</span> <span class="nav-text">主动更新策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">4.2.5.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">4.2.6.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">4.2.7.</span> <span class="nav-text">缓存击穿</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">4.3.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">4.3.1.</span> <span class="nav-text">乐观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS%E6%B3%95"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">CAS法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">4.3.2.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">基于Redis的分布式锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E8%BF%9BRedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">改进Redis的分布式锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E7%9A%84Lua%E8%84%9A%E6%9C%AC"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">Redis的Lua脚本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redisson"><span class="nav-number">4.4.</span> <span class="nav-text">Redisson</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE"><span class="nav-number">4.4.1.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redisson%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">4.4.2.</span> <span class="nav-text">Redisson可重入锁的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">4.4.3.</span> <span class="nav-text">Redisson分布式的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">4.4.4.</span> <span class="nav-text">Redisson分布式锁主从一致性问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">4.5.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EList%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">4.5.1.</span> <span class="nav-text">基于List结构模拟消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">4.5.1.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">4.5.1.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EPubSub%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">4.5.2.</span> <span class="nav-text">基于PubSub的消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-1"><span class="nav-number">4.5.2.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="nav-number">4.5.2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">4.5.3.</span> <span class="nav-text">基于Stream的消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">4.5.3.1.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="nav-number">4.5.4.</span> <span class="nav-text">基于Stream的消息队列-消费者组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-1"><span class="nav-number">4.5.4.1.</span> <span class="nav-text">特点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.6.</span> <span class="nav-text">GEO数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BitMap"><span class="nav-number">4.7.</span> <span class="nav-text">BitMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HyperLogLog%E7%94%A8%E6%B3%95"><span class="nav-number">4.8.</span> <span class="nav-text">HyperLogLog用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="nav-number">4.9.</span> <span class="nav-text">分布式缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">4.9.1.</span> <span class="nav-text">Redis持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB"><span class="nav-number">4.9.1.1.</span> <span class="nav-text">RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RDB%E6%96%B9%E5%BC%8Fbgsave%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">4.9.1.1.1.</span> <span class="nav-text">RDB方式bgsave的执行流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDB%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="nav-number">4.9.1.1.2.</span> <span class="nav-text">RDB的执行时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDB%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">4.9.1.1.3.</span> <span class="nav-text">RDB的缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF"><span class="nav-number">4.9.1.2.</span> <span class="nav-text">AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94"><span class="nav-number">4.9.1.2.1.</span> <span class="nav-text">对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="nav-number">4.9.2.</span> <span class="nav-text">主从架构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="nav-number">4.9.2.0.1.</span> <span class="nav-text">数据同步原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">4.9.2.0.2.</span> <span class="nav-text">全量同步的原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">4.9.2.0.3.</span> <span class="nav-text">全量同步与增量同步的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E6%97%B6%E6%9C%BA"><span class="nav-number">4.9.2.0.4.</span> <span class="nav-text">执行全量同步时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E6%97%B6%E6%9C%BA"><span class="nav-number">4.9.2.0.5.</span> <span class="nav-text">执行增量同步时机</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%93%A8%E5%85%B5"><span class="nav-number">4.9.3.</span> <span class="nav-text">Redis哨兵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">4.9.3.1.</span> <span class="nav-text">哨兵的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7"><span class="nav-number">4.9.3.2.</span> <span class="nav-text">服务状态监控</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E4%B8%BE%E6%96%B0%E7%9A%84master"><span class="nav-number">4.9.3.3.</span> <span class="nav-text">选举新的master</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="nav-number">4.9.3.4.</span> <span class="nav-text">实现故障转移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sentinel%E7%9A%84%E4%B8%89%E4%B8%AA%E4%BD%9C%E7%94%A8"><span class="nav-number">4.9.3.5.</span> <span class="nav-text">Sentinel的三个作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RedisTemplate%E7%9A%84%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.9.3.6.</span> <span class="nav-text">RedisTemplate的哨兵模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="nav-number">4.9.4.</span> <span class="nav-text">Redis分片集群</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E6%8F%92%E6%A7%BD"><span class="nav-number">4.9.4.1.</span> <span class="nav-text">散列插槽</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Redis%E5%88%A4%E6%96%ADkey%E4%B8%8E%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="nav-number">4.9.4.1.1.</span> <span class="nav-text">Redis判断key与实例的对应关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E4%B8%80%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%9B%BA%E5%AE%9A%E4%BF%9D%E5%AD%98%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AARedis%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">4.9.4.1.2.</span> <span class="nav-text">将一类数据固定保存到同一个Redis实例的方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9"><span class="nav-number">4.9.4.2.</span> <span class="nav-text">集群伸缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="nav-number">4.9.4.3.</span> <span class="nav-text">故障转移</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB"><span class="nav-number">4.9.4.3.1.</span> <span class="nav-text">数据迁移</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RedisTemplate%E8%AE%BF%E9%97%AE%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="nav-number">4.9.4.4.</span> <span class="nav-text">RedisTemplate访问分片集群</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">4.9.5.</span> <span class="nav-text">多级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%BC%93%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">4.9.5.1.</span> <span class="nav-text">传统缓存的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88"><span class="nav-number">4.9.5.2.</span> <span class="nav-text">多级缓存方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JVM%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98"><span class="nav-number">4.9.5.3.</span> <span class="nav-text">JVM进程缓存</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">5.</span> <span class="nav-text">原理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1"><span class="nav-number">5.1.</span> <span class="nav-text">Redis数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2SDS"><span class="nav-number">5.1.1.</span> <span class="nav-text">动态字符串SDS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-2"><span class="nav-number">5.1.1.1.</span> <span class="nav-text">优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IntSet"><span class="nav-number">5.1.2.</span> <span class="nav-text">IntSet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dict"><span class="nav-number">5.1.3.</span> <span class="nav-text">Dict</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Dict%E7%9A%84%E6%89%A9%E5%AE%B9"><span class="nav-number">5.1.3.1.</span> <span class="nav-text">Dict的扩容</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dict%E7%9A%84%E6%94%B6%E7%BC%A9"><span class="nav-number">5.1.3.2.</span> <span class="nav-text">Dict的收缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Dict%E7%9A%84rehash"><span class="nav-number">5.1.3.3.</span> <span class="nav-text">Dict的rehash</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZipList"><span class="nav-number">5.1.4.</span> <span class="nav-text">ZipList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Encoding%E7%BC%96%E7%A0%81"><span class="nav-number">5.1.4.1.</span> <span class="nav-text">Encoding编码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#QuickList"><span class="nav-number">5.1.5.</span> <span class="nav-text">QuickList</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SkipList"><span class="nav-number">5.1.6.</span> <span class="nav-text">SkipList</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-2"><span class="nav-number">5.1.6.1.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RedisObject"><span class="nav-number">5.1.7.</span> <span class="nav-text">RedisObject</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#String"><span class="nav-number">5.1.7.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#List"><span class="nav-number">5.1.7.2.</span> <span class="nav-text">List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Set"><span class="nav-number">5.1.7.3.</span> <span class="nav-text">Set</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZSet"><span class="nav-number">5.1.7.4.</span> <span class="nav-text">ZSet</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Hash"><span class="nav-number">5.1.8.</span> <span class="nav-text">Hash</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="nav-number">5.2.</span> <span class="nav-text">Redis网络模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4"><span class="nav-number">5.2.1.</span> <span class="nav-text">用户空间和内核空间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EIO"><span class="nav-number">5.2.2.</span> <span class="nav-text">阻塞IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-number">5.2.3.</span> <span class="nav-text">非阻塞IO</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="nav-number">5.2.4.</span> <span class="nav-text">IO多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#select"><span class="nav-number">5.2.4.1.</span> <span class="nav-text">select</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#poll"><span class="nav-number">5.2.4.2.</span> <span class="nav-text">poll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#epoll"><span class="nav-number">5.2.4.3.</span> <span class="nav-text">epoll</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO"><span class="nav-number">5.2.4.4.</span> <span class="nav-text">信号驱动IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5IO"><span class="nav-number">5.2.4.5.</span> <span class="nav-text">异步IO</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis"><span class="nav-number">5.2.5.</span> <span class="nav-text">Redis</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="nav-number">5.2.5.1.</span> <span class="nav-text">Redis通信协议</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RESP"><span class="nav-number">5.2.5.1.1.</span> <span class="nav-text">RESP</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.2.5.1.1.1.</span> <span class="nav-text">数据类型</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%86%85%E5%AD%98%E7%AD%96%E7%95%A5"><span class="nav-number">5.3.</span> <span class="nav-text">Redis内存策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6"><span class="nav-number">5.3.1.</span> <span class="nav-text">Redis内存回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="nav-number">5.3.2.</span> <span class="nav-text">过期策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5-DB%E7%BB%93%E6%9E%84"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">过期策略-DB结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5-%E6%83%B0%E6%80%A7%E5%88%A0%E9%99%A4"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">过期策略-惰性删除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5-%E5%91%A8%E6%9C%9F%E5%88%A0%E9%99%A4"><span class="nav-number">5.3.2.3.</span> <span class="nav-text">过期策略-周期删除</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="nav-number">5.3.3.</span> <span class="nav-text">淘汰策略</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MANVND</p>
  <div class="site-description" itemprop="description">There is no royal road to learning</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MANVND</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
