<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Redis_Base">
<meta property="og:url" content="http://example.com/2023/09/18/redis/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/09/18/redis/duanxindenglu.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/tianjiaredishuancun.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/huchisuo.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/luojiguoqi.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/Redissonkechongrusuoyuanli.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/zhucongdiyicitongbu.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/zengliangtongbu.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/shaobingjiegou.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/shujuqianyi.png">
<meta property="og:image" content="http://example.com/2023/09/18/redis/duojihuancun.png">
<meta property="article:published_time" content="2023-09-18T07:59:53.000Z">
<meta property="article:modified_time" content="2023-11-10T09:27:42.679Z">
<meta property="article:author" content="MANVND">
<meta property="article:tag" content="JavaWeb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/09/18/redis/duanxindenglu.png">

<link rel="canonical" href="http://example.com/2023/09/18/redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Redis_Base | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/09/18/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MANVND">
      <meta itemprop="description" content="There is no royal road to learning">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Redis_Base
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-09-18 15:59:53" itemprop="dateCreated datePublished" datetime="2023-09-18T15:59:53+08:00">2023-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-11-10 17:27:42" itemprop="dateModified" datetime="2023-11-10T17:27:42+08:00">2023-11-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <html><head></head><body><h1 id="Redis基础使用"><a href="#Redis基础使用" class="headerlink" title="Redis基础使用"></a>Redis基础使用</h1><h2 id="NoSQL特性"><a href="#NoSQL特性" class="headerlink" title="NoSQL特性"></a>NoSQL特性</h2><ul>
<li>数据结构：数据往往以非结构化的方式存储</li>
<li>数据关联：无关联的</li>
<li>查询方式：非SQL语句查询</li>
<li>事务特性：无法满足ACID，而是BASE</li>
<li>存储方式：内存</li>
<li>拓展性：水平</li>
</ul>
<h2 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h2><p>基于<strong>内存</strong>的键值型NoSQL数据库。</p>
<ul>
<li>键值型，value支持多种不同数据结构，功能丰富；</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（基于内存、IO多路复用、良好的编码）</li>
<li>支持数据持久化</li>
<li>支持主从集群、分片集群</li>
</ul>
<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis是一个key-value数据库，key一般是String类型，value的类型多种多样：</p>
<p>String, Hash, List, Set, SortedSet, GEO, BitMap, HyperLog</p>
<h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>通用命令是不分数据类型的，都可以使用的指令，常见的有：</p>
<ul>
<li>KEYS：查看符合模板的所有key，后接匹配模式pattern，不建议在生产环境设备上使用</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEYS *</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>DEL：删除一个指定key，后接一个或多个key的名称</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL keyName</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>EXISTS：查看一个key是否存在，后接key的名称</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS keyName</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>EXPIRE：给一个key设置有效期，有效期到期key会自动被删除</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE keyName time</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>TTL：查看一个key的剩余有效期</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TTL keyName</span><br></pre></td></tr></tbody></table></figure>

<p>可以通过help[command]查看一个命令的具体用法。</p>
<h2 id="String类型命令"><a href="#String类型命令" class="headerlink" title="String类型命令"></a>String类型命令</h2><p>String类型是Redis中最简单的存储类型。其value是字符串，但根据字符串的格式不同，可以分为三类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增、自减操作</li>
<li>float：浮点类型，可以做自增、自减操作</li>
</ul>
<p>不管哪种格式，其底层都是用<strong>字节数组</strong>形式存储，只不过编码方式不同。字符串类型的最大空间不能超过512m。</p>
<p>String的常见命令有：</p>
<ul>
<li>SET：添加或修改已经存在的一个String类型的键值对</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [NX | XX] [GET] [EX seconds | PX milliseconds | EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>GET：根据key获取String类型的value</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>MSET：批量添加多个String类型的键值对</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>MGET：根据多个key获取多个String类型的value</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MGET key [key ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>INCR：让一个整形的key的值自增1</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>INCRBY：让一个整形的key的值自增并指定步长</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBY key increment</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBYFLOAT key increment</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SETEX：添加一个String类型的键值对，并且指定有效期</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETEX key seconds value</span><br></pre></td></tr></tbody></table></figure>

<h2 id="key的结构"><a href="#key的结构" class="headerlink" title="key的结构"></a>key的结构</h2><p>Redis的key允许多个单词形成层级结构，多个单词之间用’.’隔开，格式如下：</p>
<p>项目名:业务名:类型:id</p>
<h2 id="Hash类型命令"><a href="#Hash类型命令" class="headerlink" title="Hash类型命令"></a>Hash类型命令</h2><p>Hash类型，也叫散列，其value是一个无序字，类似于Java中的HashMap结构。</p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。</p>
<table>
  <tbody text-align="center">
    <tr>
        <th rowspan="2">KEY</th>
      <th colspan="2">VALUE</th>
    </tr>
      <tr>
        <td>field</td>
      <td>value</td>
    </tr>
  </tbody>
</table>


<p>Hash类型的常见命令：</p>
<ul>
<li>HSET: 添加或修改hash类型key的field的值</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HGSET：获取一个hash类型key的filed的值</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGET key field</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HMSET：批量添加多个hash类型key的field的值</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMSET key field value [field value ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HMGET：批量获取多个hash类型key的field的值</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field [field ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HGETALL：获取一个hash类型的key中的所有field和value</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGETALL key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HKEYS：获取一个hash类型的key中所有的field</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEYS key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HVALS：获取一个hash类型的key中的所有value</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HVALS key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HINCRBY：让一个hash类型key的字段值自增并指定步长</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行。</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX key field value</span><br></pre></td></tr></tbody></table></figure>

<h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做一个双向链表结构。既可以正向检索也可以反向检索</p>
<p>特征：</p>
<ul>
<li>有序</li>
<li>元素可以重复插入</li>
<li>插入和删除块</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据</p>
<p>List的常见命令有：</p>
<ul>
<li>LPUSH：向列表左侧插入一个或多个元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key element [element ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>LPOP：移除并返回列表左侧的第一个元素，没有返回null</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPOP key [count]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>RPUSH：向列表右侧插入一个或多个元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSH key element [element ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>RPOP：移除并返回列表右侧第一个元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOP key [count]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>LRANGE：返回一段角标范围内的所有元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>BLPOP与BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回null</li>
</ul>
<h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具有与HashSet类似的特征：</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集、并集、差集等功能</li>
</ul>
<p>Set的常见命令有：</p>
<ul>
<li>SADD：向set中添加一个或多个元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SREM：移除set中的指定元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SCARD：返回set中元素的个数</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SISMEMBER：判断一个元素是否存在于set中</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SMEMBERS：获取set中的所有元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SINTER：求key1与key2的交集</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SDIFF：求key1与key2的差集</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key [key ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>SUNION：求key1与key2的并集</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNION key [key ...]</span><br></pre></td></tr></tbody></table></figure>

<h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis的Sorted是一个可排序的set集合，与Java中的TreeSet功能类似，但底层数据结构差别很大。SortedSet中的每个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表加hash表</p>
<p>SortedSet具有以下特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>SortedSet的常见命令有：</p>
<ul>
<li>ZADD：添加一个或多个元素到sorted set，如果已经存在则更新其score值</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZREM：删除sorted set中的一个指定元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZSCORE：获取sorted set中的指定元素的score值</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZRANK：获取sorted set中的指定元素的排名</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANK key member [WITHSCORE]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZCARD：获取sorted set 中的元素个数</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZCOUNT：统计score值在给定范围内的所有元素的个数</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZINCRBY：让sorted set中的指定元素自增，步长为指定的increment值</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZRANGE：按照score排序后，获取指定排名范围内的元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZRANGEBYSCORE：按照score排序后，获取指定score范围内的元素</li>
</ul>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li>
</ul>
<p>所有排名默认升序，如果要降序则在命令Z后添加<strong>REV</strong>即可</p>
<h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此可以使用Jedis连接池</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">jedisPoolConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        jedisPoolConfig.setMaxWait(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(jedisPoolConfig, <span class="string">"127.0.0.1"</span>, <span class="number">6379</span>, <span class="number">1000</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedisPool</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h2 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h2><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫SpringDataRedis</p>
<ul>
<li>提供了对不同Redis客户端的整合</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持给予JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<h3 id="SpringDataRedis快速使用"><a href="#SpringDataRedis快速使用" class="headerlink" title="SpringDataRedis快速使用"></a>SpringDataRedis快速使用</h3><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并将不同数据类型的操作API封装到了不同的类型中</p>
<table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">返回值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">redisTemplate.opsForValue()</td>
<td align="center">ValueOperations</td>
<td align="center">操作String类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate.opsForHash()</td>
<td align="center">HashOperatiions</td>
<td align="center">操作Hash类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate.opsForList()</td>
<td align="center">ListOperations</td>
<td align="center">操作List类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate.opsForSet()</td>
<td align="center">SetOperations</td>
<td align="center">操作Set类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate.opsForZSet()</td>
<td align="center">ZSetOperations</td>
<td align="center">操作SortedSet类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate</td>
<td align="center"></td>
<td align="center">通用的命令</td>
</tr>
</tbody></table>
<h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 最大连接</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment"># 最大空闲连接</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment"># 最小空闲连接</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="number">100</span> <span class="comment"># 连接等待时间</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="注入RedisTemplate"><a href="#注入RedisTemplate" class="headerlink" title="注入RedisTemplate"></a>注入RedisTemplate</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> REdisTemplate redisTemplate</span><br></pre></td></tr></tbody></table></figure>

<h3 id="SpringDataRedis的序列化方式"><a href="#SpringDataRedis的序列化方式" class="headerlink" title="SpringDataRedis的序列化方式"></a>SpringDataRedis的序列化方式</h3><p>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认采用JDK序列化</p>
<p>缺点：</p>
<ul>
<li>可读性差</li>
<li>内存占用较大</li>
</ul>
<p>可以自定义RedisTemplate的序列化方式：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> {</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置value的序列化</span></span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(<span class="keyword">new</span> <span class="title class_">GenericJackson2JsonRedisSerializer</span>());</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<p>为了实现序列化与反序列化，Template会在Redis数据库中存储”@Class”保存该数据的类，但因此也会产生额外的内存开销</p>
<p>为了节省空间，一般不会用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化</p>
<p>Spring默认提供一个StringRedisTemplate类，它的key和value的序列化默认就是String方式</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">mapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException {</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">"虎哥"</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">// 手动序列化</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">"user:100"</span>, json);</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonUser</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().get(<span class="string">"user:100"</span>);</span><br><span class="line">        <span class="comment">// 手动反序列化</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> mapper.readValue(jsonUser, User.class);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>

<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="Session实现用户短信登录"><a href="#Session实现用户短信登录" class="headerlink" title="Session实现用户短信登录"></a>Session实现用户短信登录</h2><p><img src="/2023/09/18/redis/duanxindenglu.png" alt="duanxindenglu"></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="缓存的简介"><a href="#缓存的简介" class="headerlink" title="缓存的简介"></a>缓存的简介</h3><p><strong>缓存</strong>就是数据交换的缓冲区，是存储数据的临时地方，一般读写性能较高。</p>
<p>浏览器：浏览器缓存</p>
<p>tomcat：应用层缓存</p>
<p>数据库：数据库缓存</p>
<p>作用：</p>
<ul>
<li>降低后端负载</li>
<li>提高读写效率，降低响应时间</li>
</ul>
<p>成本：</p>
<ul>
<li>数据一致性成本</li>
<li>代码维护成本</li>
<li>运维成本</li>
</ul>
<h3 id="添加Redis缓存"><a href="#添加Redis缓存" class="headerlink" title="添加Redis缓存"></a>添加Redis缓存</h3><p><img src="/2023/09/18/redis/tianjiaredishuancun.png" alt="tianjiaredishuancun"></p>
<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><table>
<thead>
<tr>
<th></th>
<th>内存淘汰</th>
<th>超时剔除</th>
<th>主动更新</th>
</tr>
</thead>
<tbody><tr>
<td><strong>说明</strong></td>
<td>不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存</td>
<td>给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存</td>
<td>编写业务逻辑，在修改数据库的同时，更新缓存</td>
</tr>
<tr>
<td><strong>一致性</strong></td>
<td>差</td>
<td>一般</td>
<td>好</td>
</tr>
<tr>
<td><strong>维护成本</strong></td>
<td>无</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><ol>
<li>由缓存的调用者，在更新数据库的同时更新缓存</li>
</ol>
<ul>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li>
<li>单体系统：将缓存与数据库操作放在一个事务；分布式系统，利用TTC等分布式事务方案</li>
</ul>
<ol>
<li>缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题</li>
<li>调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保持最终一致</li>
</ol>
<p>最佳实践方案：</p>
<ol>
<li>低一致性需求：使用Redis自带的内存淘汰机制</li>
<li>高一致性需求：主动更新，并以超时剔除作为兜底方案</li>
</ol>
<ul>
<li>读操作：<ul>
<li>缓存命中则直接返回</li>
<li>缓存命中则查询数据库，并写入缓存，设定超时时间</li>
</ul>
</li>
<li>写操作：<ul>
<li>先写数据库，然后再删除缓存</li>
<li>要确保数据库与缓存操作的原子性</li>
</ul>
</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都回到数据库</p>
<ul>
<li>缓存空对象：当将空对象存储在缓存中<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤：在客户端与缓存间添加一层——布隆过滤器<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>缓存雪崩</strong>指同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力</p>
<p>解决方案：</p>
<ul>
<li>给不同key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务天假降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿问题</strong>也叫热点key问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求会在瞬间给数据库带来巨大的冲击</p>
<p>常见解决方案：</p>
<ul>
<li>互斥锁</li>
</ul>
<p><img src="/2023/09/18/redis/huchisuo.png" alt="huchisuo"></p>
<ul>
<li>逻辑过期</li>
</ul>
<p><img src="/2023/09/18/redis/luojiguoqi.png" alt="luojiguoqi"></p>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>互斥锁</td>
<td>- 没有额外的内存消耗<br>- 保证一致性<br>- 实现简单</td>
<td>- 线程需要等待，性能受到影响 <br>- 可能有死锁风险</td>
</tr>
<tr>
<td>逻辑过期</td>
<td>- 线程无需等待，性能较好</td>
<td>- 不保证一致性<br>- 有额外的内存消耗<br>- 实现复杂</td>
</tr>
</tbody></table>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul>
<li><p>悲观锁：认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。</p>
</li>
<li><p>乐观锁：认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其他线程对数据做了修改。</p>
<ul>
<li>如果没有修改则认为是安全的，自己才更新数据；</li>
<li>如果已经被其他线程修改说明发生了安全问题，此时可以重试或异常</li>
</ul>
</li>
</ul>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁的关键是判断之前查询得到的数据是否有被修改过</p>
<h4 id="CAS法"><a href="#CAS法" class="headerlink" title="CAS法"></a>CAS法</h4><p>给数据添加版本号，根据版本号是否变化判断是否有别的线程修改了数据</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁</p>
<p>分布式锁的核心是实现多进程之间的互斥，而满足这一点的方式有很多，常见的有三种：</p>
<table>
<thead>
<tr>
<th></th>
<th>MySQL</th>
<th>Redis</th>
<th>Zookeeper</th>
</tr>
</thead>
<tbody><tr>
<td>互斥</td>
<td>利用MySQL本身的互斥锁机制</td>
<td>利用setnx这样的互斥命令</td>
<td>利用节点的唯一性和有序性实现互斥</td>
</tr>
<tr>
<td>高可用</td>
<td>好</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>高性能</td>
<td>一般</td>
<td>好</td>
<td>一般</td>
</tr>
<tr>
<td>安全性</td>
<td>断开连接，自动释放锁</td>
<td>利用锁超时时间，到期释放</td>
<td>临时节点，断开连接自动释放</td>
</tr>
</tbody></table>
<h4 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h4><p>实现分布式锁时需要实现的两个基本方法：</p>
<ul>
<li>获取锁：<ul>
<li>互斥：确保只能有一个线程获取锁</li>
</ul>
</li>
<li>释放锁：<ul>
<li>手动释放</li>
<li>超时释放：获取锁时添加一个超时时间</li>
</ul>
</li>
</ul>
<h4 id="改进Redis的分布式锁"><a href="#改进Redis的分布式锁" class="headerlink" title="改进Redis的分布式锁"></a>改进Redis的分布式锁</h4><ol>
<li>在获取锁时存入线程标识；</li>
<li>在释放锁时先获取锁的线程标识，判断是否与当前线程标识一致<ul>
<li>如果一致则释放锁</li>
<li>如果不一致则不释放锁</li>
</ul>
</li>
</ol>
<h4 id="Redis的Lua脚本"><a href="#Redis的Lua脚本" class="headerlink" title="Redis的Lua脚本"></a>Redis的Lua脚本</h4><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。</p>
<h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包括了各种分布式锁的实现</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedissonClient <span class="title function_">redissonClient</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 配置类</span></span><br><span class="line">        <span class="type">Config</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Config</span>();</span><br><span class="line">        <span class="comment">// 添加redis地址，这里添加单点地址，也可以使用config.useClusterServers()添加集群地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">"redis://127.0.0.1:6379"</span>);</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    }</span><br><span class="line">            </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Redisson可重入锁的原理"><a href="#Redisson可重入锁的原理" class="headerlink" title="Redisson可重入锁的原理"></a>Redisson可重入锁的原理</h3><img src="/2023/09/18/redis/Redissonkechongrusuoyuanli.png" alt="Redissonkechongrusuoyuanli" style="zoom:50%;">

<p>使用Lua脚本完成上图逻辑保证原子性</p>
<h3 id="Redisson分布式的原理"><a href="#Redisson分布式的原理" class="headerlink" title="Redisson分布式的原理"></a>Redisson分布式的原理</h3><ul>
<li><strong>可重入</strong>： 利用hash结构记录线程id和重入次数</li>
<li><strong>可重试</strong>：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</li>
<li><strong>超时续约</strong>：利用watchDog，每隔一段时间（realeaseTime / 3），重置超时时间</li>
</ul>
<h3 id="Redisson分布式锁主从一致性问题"><a href="#Redisson分布式锁主从一致性问题" class="headerlink" title="Redisson分布式锁主从一致性问题"></a>Redisson分布式锁主从一致性问题</h3><p>主从模式：主节点处理写操作，从节点处理读操作</p>
<p>一致性问题：主操作更新的数据还没来得及同步到从节点，此时发生一致性问题</p>
<p>Redisson取消主从模式，所有节点均为主节点，一个应用要同时获取多个节点的锁才能获取读写操作</p>
<p>Redisson的multiLock：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功；缺陷：运维成本高，实现复杂</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列(Message Queue)，即存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也被称为消息代理；</li>
<li>生产者：发送消息到消息队列；</li>
<li>消费者：从消息队列获取消息并处理消息；</li>
</ul>
<p>Redis提供三种不同的方式来实现消息队列：</p>
<ul>
<li>list结构：基于list结构模拟消息队列</li>
<li>PubSub：基本的点对点消息模型</li>
<li>Stream：比较完善的消息队列模型</li>
</ul>
<h3 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a>基于List结构模拟消息队列</h3><p>队列的入口和出口不在一边，因此可以利用LPUSH结合RPOP、或者RPUSH结合LPOP来实现，不过，当队列中没有消息的时候RPOP或LPLP操作会返回null，并不会像JVM的阻塞队列那样阻塞并等待消息，因此应该使用<strong>BRPOP</strong>或者<strong>BLPOP</strong>来实现阻塞效果</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>基于Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保证</li>
<li>可以满足消息有序性</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>无法避免消息丢失</li>
<li>只支持单消费者</li>
</ul>
<h3 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息</p>
<ul>
<li>SUBSCRIBE channel [channel]: 订阅一个或多个频道</li>
<li>PUBLISH channel msg: 向一个频道发送消息</li>
<li>PSUBSCRIBE pattern [pattern]: 订阅与pattern格式匹配的所有频道</li>
</ul>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>采用发布订阅模型，支持多生产，多消费</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不支持数据持久化</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失</li>
</ul>
<h3 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h3><p>Stream是Redis5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列</p>
<p>发送消息的命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD key [NOMKSTREAM] [MAXLEN|MINID [=|~] threshold [LIMIT count]] *|ID field value [field value ...]</span><br></pre></td></tr></tbody></table></figure>

<p>读取消息的命令：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREAD [COUNT count] [BLOCK milliseconds] [STREAMS key [key ...] ID [ID ...]]</span><br></pre></td></tr></tbody></table></figure>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h3 id="基于Stream的消息队列-消费者组"><a href="#基于Stream的消息队列-消费者组" class="headerlink" title="基于Stream的消息队列-消费者组"></a>基于Stream的消息队列-消费者组</h3><p>消费者组：将对个消费者划分到一个组中，监听同一个队列。具有如下特点：</p>
<ol>
<li>消息分流：队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度</li>
<li>消息标示：消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费</li>
<li>消息确认：消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记该消息为已处理，才会从pending-list移除</li>
</ol>
<p>创建消费者组：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE key groupName ID [MKSTREAM]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>key：队列名称</li>
<li>groupName：消费者组名称</li>
<li>ID：起始ID标示，￥标示队列中最后一个消息，0则代表队列中第一个消息</li>
<li>MKSTREAM：队列不存在时自动创建队列</li>
</ul>
<p>其他常见命令</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除指定的消费者组</span></span><br><span class="line">XGROUP DESTROY key groupName</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给指定的消费者组天假消费者</span></span><br><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除消费者组中的指定消费者</span></span><br><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></tbody></table></figure>

<p>从消费者组读取消息：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>group：消费组名称</li>
<li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li>
<li>count：本次查询的最大数量</li>
<li>BLOCK milliseconds：当没有消息时最长等待时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认</li>
<li>STREAMS key：指定消息名称</li>
<li>ID：获取消息的起始ID：<ul>
<li>“&gt;”：从下一个未消费的消息开始</li>
<li>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</li>
</ul>
</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消费漏读风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>
<h2 id="GEO数据结构"><a href="#GEO数据结构" class="headerlink" title="GEO数据结构"></a>GEO数据结构</h2><p>GEO就是Geolocation的简写形式，代表地理坐标。Redis在3.2版本加入了对GEO的支持，允许存储地理坐标信息。常见的命令有：</p>
<ul>
<li>GEOADD：添加一个地理空间信息，包括经度（longitude）、维度（latitude）、值（member）</li>
<li>GEODIST：计算指定的两个点之间的距离并返回</li>
<li>GEOHASH：将指定member的坐标转为hash字符串形式并返回</li>
<li>GEOPOS：返回指定member的坐标</li>
<li>GEORADIUS：指定圆心、半径，找到该圆内包含的所有member，并按照与圆心之间的距离排序后返回</li>
<li>GEOSEARCH：在指定范围内搜索member，并按照与指定点之间的距离排序后返回。范围可以是圆形或矩形</li>
<li>GEOSEARCHSTORE：与GEOSEARCH功能一致，不过可以吧结果存储到一个指定的key</li>
</ul>
<h2 id="BitMap"><a href="#BitMap" class="headerlink" title="BitMap"></a>BitMap</h2><p>位图，将每个bit位与业务对应，0，1表示业务状态。</p>
<p><strong>Redis</strong>中利用string类型数据结构实现<strong>BitMap</strong>，因此最大上限是512M，转换bit则是2^32个bit位</p>
<p>BitMap的操作命令有：</p>
<ul>
<li>SETBIT：向指定位置（offset）存入一个0或1</li>
<li>GETBIT：获取指定位置（offset）的bit值</li>
<li>BITCOUNT：统计BitMap中值为1的bit位的数量</li>
<li>BITFIELD：操作（查询、修改、自增）BitMap中bit数组中指定位置（offset）的值</li>
<li>BITFIELD_RO：获取BitMap中bit数组，并以十进制形式返回</li>
<li>BITOP：将多个BitMap的结果做位运算（与、或、异或）</li>
<li>BITPOS：查找bit数组中指定范围内第一个0或1出现的位置</li>
</ul>
<h2 id="HyperLogLog用法"><a href="#HyperLogLog用法" class="headerlink" title="HyperLogLog用法"></a>HyperLogLog用法</h2><ul>
<li>UV：全称Unique Visitor，也叫独立访问量，指通过互联网那个访问、浏览这个网页的自然人。一天内同一个用户多次访问该网站，只记录一次</li>
<li>PV：全称Page View，也叫页面访问量或点击量，用户每访问网站的一个页面，记录1次PV，用户多次打开页面，则记录多次PV。往往用来衡量网站的流量</li>
</ul>
<p>HyperLogLog（HLL）是从LogLog算法派生的概率算法，用于确定非常大的集合的基数，而不需要存储其所有值。</p>
<p>Redis中的HLL是基于string结构实现的，单个HLL的内存永远小于16kb，内存占用低，作为代价，有小于0.81%的误差。不过对于UV统计来说，这完全可以忽略</p>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h3 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h3><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>RDB全程Redis Database Backup file（Redis数据备份文件），也叫做Redis数据快照。即把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据</p>
<p>快照文件称为RDB文件，默认保存在当前目录</p>
<ul>
<li>save：由Redis主进程来执行RDB，会阻塞所有命令</li>
<li>bgsave：开启子进程执行RDB，避免主进程收到影响</li>
</ul>
<p>RDB停机时会执行一次RDB</p>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">900秒内，如果至少有1个key被修改，则执行bgsave，如果save <span class="string">""</span> 则表示禁用RDB</span></span><br><span class="line">save &lt;seconds&gt; &lt;change&gt;</span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></tbody></table></figure>

<p>RDB的其它配置也可以在redis.conf文件中设置：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否压缩，建议不开启，压缩会消耗CPU，磁盘不值钱</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">RDB文件名称</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">文件保存的路径目录</span></span><br><span class="line">dir ./</span><br></pre></td></tr></tbody></table></figure>

<p>bgsave开始时会fork主进程得到子进程，子进程<strong>共享</strong>主进程的内存数据。完成fork后读取内存数据并写入RDB文件</p>
<p>fork采取的是copy-on-write技术：</p>
<ul>
<li>当主进程执行读操作时，访问共享内存</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作</li>
</ul>
<h5 id="RDB方式bgsave的执行流程"><a href="#RDB方式bgsave的执行流程" class="headerlink" title="RDB方式bgsave的执行流程"></a>RDB方式bgsave的执行流程</h5><ul>
<li>fork主进程得到一个子进程，共享内存空间</li>
<li>子进程读取内存数据并写入新的RDB文件</li>
<li>用新的RDB文件替换旧的RDB文件</li>
</ul>
<h5 id="RDB的执行时机"><a href="#RDB的执行时机" class="headerlink" title="RDB的执行时机"></a>RDB的执行时机</h5><ul>
<li>默认是服务停止时</li>
</ul>
<h5 id="RDB的缺点"><a href="#RDB的缺点" class="headerlink" title="RDB的缺点"></a>RDB的缺点</h5><ul>
<li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li>
<li>fork子进程、压缩、写入数据有数据丢失的风险</li>
</ul>
<h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF全程为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看作是命令日志文件</p>
<p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">是否开启AOF功能，默认是no</span></span><br><span class="line">appendonly yes</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF文件的名称</span></span><br><span class="line">appendfilename "appendonly.aof"</span><br></pre></td></tr></tbody></table></figure>

<p>AOF的命令记录的频率也可以通过redis.cnf文件来配置：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">表示每执行一次写命令，立刻记录到AOF文件</span></span><br><span class="line">appendfsync always</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写命令执行完先放入AOF缓冲区，然后表示每隔一秒讲缓冲区数据写到AOF文件，是默认方案</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">写命令执行完先放入AOF缓冲区，由操作系统决定何时讲缓冲区内容写回磁盘</span></span><br><span class="line">appendfsync no</span><br></pre></td></tr></tbody></table></figure>

<table>
<thead>
<tr>
<th>配置项</th>
<th>刷盘时机</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Always</td>
<td>同步刷盘</td>
<td>可靠性高，几乎不丢失数据</td>
<td>性能影响大</td>
</tr>
<tr>
<td>everysec</td>
<td>每秒刷盘</td>
<td>性能适中</td>
<td>最多丢失一秒数据</td>
</tr>
<tr>
<td>no</td>
<td>操作系统控制</td>
<td>性能最好</td>
<td>可靠性较差，可能丢失大量数据</td>
</tr>
</tbody></table>
<p>因为记录命令，AOF文件会比RDB文件大很多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行<strong>bgrewriteaof</strong>命令，可以让AOF文件执行重写功能，用最少得命令达到相同效果</p>
<p>Redis也会在触发阈值时自动重写AOF文件。阈值也可以在redis.conf中配置</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF文件比上次文件 增长超过多少百分比则触发重写</span></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">AOF文件体积最小多大以上才触发重写</span></span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></tbody></table></figure>

<h5 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h5><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">RDB</th>
<th align="center">AOF</th>
</tr>
</thead>
<tbody><tr>
<td align="center">持久化方式</td>
<td align="center">定时对整个内存做快照</td>
<td align="center">记录每一次执行的命令</td>
</tr>
<tr>
<td align="center">数据完整性</td>
<td align="center">不完整，两次备份之间会丢失</td>
<td align="center">相对完整，取决于刷盘策略</td>
</tr>
<tr>
<td align="center">文件大小</td>
<td align="center">会有压缩，文件体积小</td>
<td align="center">记录命令，文件体积很大</td>
</tr>
<tr>
<td align="center">宕机回复速度</td>
<td align="center">很快</td>
<td align="center">慢</td>
</tr>
<tr>
<td align="center">数据恢复优先级</td>
<td align="center">低，因为数据完整性不如AOF</td>
<td align="center">高，因为数据完整性更高</td>
</tr>
<tr>
<td align="center">系统资源占用</td>
<td align="center">高，大量CPU和内存消耗</td>
<td align="center">低，主要是磁盘IO资源但AOF重写时会赵勇大量CPU和内存资源</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">可以容忍数分钟的数据丢失，追求更高的启动速度</td>
<td align="center">对数据安全性要求较高，常见</td>
</tr>
</tbody></table>
<h3 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h3><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离</p>
<p>master节点负责写操作，slave/replica节点负责读操作</p>
<h5 id="数据同步原理"><a href="#数据同步原理" class="headerlink" title="数据同步原理"></a>数据同步原理</h5><img src="/2023/09/18/redis/zhucongdiyicitongbu.png" alt="zhucongdiyicitongbu" style="zoom:50%;">

<p>master判断slave是否是第一次同步数据的依据：</p>
<ul>
<li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li>
<li><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新</li>
</ul>
<p>因为slave做数据同步，必须向master声明自己的<strong>replication id</strong>和<strong>offset</strong>，master才可以判断到底需要同步哪些数据</p>
<p>上图1.1中<strong>通过判断主从节点的replid是否一致来判断主从节点是否是第一次同步</strong></p>
<h5 id="全量同步的原理"><a href="#全量同步的原理" class="headerlink" title="全量同步的原理"></a>全量同步的原理</h5><ul>
<li>slave节点请求增量同步</li>
<li>master节点判断replid，发现不一致，拒绝增量同步</li>
<li>master将完整内存数据生成RDB，发送RDB到slave</li>
<li>slave清空本地数据，加载master的RDB</li>
<li>master将RDB期间的命令记录到repl_baklog，并持续将log中的命令发送个slave</li>
<li>slave执行接收到的命令，保持与master之间的同步</li>
</ul>
<img src="/2023/09/18/redis/zengliangtongbu.png" alt="zengliangtongbu" style="zoom:50%;">

<p>repl_baklog大小有上限，写满后会覆盖最早的数据。如果slave断开时间过久，导致尚未备份的数据被覆盖，则无法基于log做增量同步，只能再次全量同步</p>
<p>可以从以下几个方面优化Redis主从集群：</p>
<ul>
<li>在master中配置repl_diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO</li>
<li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li>
<li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li>
<li>限制一个master上的slave节点数量，如果是在是太多slave，则可以采用主-从-从链式结构，减少master压力</li>
</ul>
<h5 id="全量同步与增量同步的区别"><a href="#全量同步与增量同步的区别" class="headerlink" title="全量同步与增量同步的区别"></a>全量同步与增量同步的区别</h5><ul>
<li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令记录到repl_baklog，逐个发送给slave</li>
<li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li>
</ul>
<h5 id="执行全量同步时机"><a href="#执行全量同步时机" class="headerlink" title="执行全量同步时机"></a>执行全量同步时机</h5><ul>
<li>slave节点第一次连接master节点时</li>
<li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li>
</ul>
<h5 id="执行增量同步时机"><a href="#执行增量同步时机" class="headerlink" title="执行增量同步时机"></a>执行增量同步时机</h5><ul>
<li>slave节点断开又恢复，并且在repl_baklog中能找到offset时</li>
</ul>
<h3 id="Redis哨兵"><a href="#Redis哨兵" class="headerlink" title="Redis哨兵"></a>Redis哨兵</h3><h4 id="哨兵的作用"><a href="#哨兵的作用" class="headerlink" title="哨兵的作用"></a>哨兵的作用</h4><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。哨兵的结构和作用如下：</p>
<ul>
<li><strong>监控</strong>：Sentinel会不断检查master和slave是否按预期工作</li>
<li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例回复后也以新的master为主</li>
<li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最近信息推送给Redis的客户端</li>
</ul>
<p>结构：</p>
<img src="/2023/09/18/redis/shaobingjiegou.png" alt="shaobingjiegou" style="zoom:67%;">

<h4 id="服务状态监控"><a href="#服务状态监控" class="headerlink" title="服务状态监控"></a>服务状态监控</h4><p>Sentinel基于心跳机制监测服务状态，每隔一秒向集群的每个实例发送ping命令：</p>
<ul>
<li>主观下线：如果某个sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong></li>
<li>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最后超过Sentinel实例数量的一半</li>
</ul>
<h4 id="选举新的master"><a href="#选举新的master" class="headerlink" title="选举新的master"></a>选举新的master</h4><p>一旦发现master故障，sentine需要在slave中选择一个作为新的master，选择依据是：</p>
<ul>
<li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li>
<li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li>
<li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li>
<li>最后判断slave节点的运行id大小，越小优先级越高</li>
</ul>
<h4 id="实现故障转移"><a href="#实现故障转移" class="headerlink" title="实现故障转移"></a>实现故障转移</h4><p>当选中了其中一个slave为新的master后，故障的转移步骤如下：</p>
<ul>
<li>sentinel给备选的slave节点发送slaveof no one命令，让该节点成为master</li>
<li>sentinel给所有其他slave发送slaveof &lt;ip&gt; &lt;端口&gt;命令，让这些slave成为新master的从节点，开始从新的master上同步数据</li>
<li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的maaster的slave节点</li>
</ul>
<h4 id="Sentinel的三个作用"><a href="#Sentinel的三个作用" class="headerlink" title="Sentinel的三个作用"></a>Sentinel的三个作用</h4><ul>
<li>监控</li>
<li>故障转移</li>
<li>通知</li>
</ul>
<h4 id="RedisTemplate的哨兵模式"><a href="#RedisTemplate的哨兵模式" class="headerlink" title="RedisTemplate的哨兵模式"></a>RedisTemplate的哨兵模式</h4><p>在Sentinel集群监督下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知与自动切换</p>
<h3 id="Redis分片集群"><a href="#Redis分片集群" class="headerlink" title="Redis分片集群"></a>Redis分片集群</h3><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>
<ul>
<li>海量数据存储问题</li>
<li>高并发写的问题</li>
</ul>
<p>使用分片集群可以解决上述问题，分片集群特征：</p>
<ul>
<li>集群中有多个master，每个master保存不同数据</li>
<li>每个master都可以有多个slave节点</li>
<li>master之间通过ping监测彼此健康状态</li>
<li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</li>
</ul>
<h4 id="散列插槽"><a href="#散列插槽" class="headerlink" title="散列插槽"></a>散列插槽</h4><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到</p>
<p>数据key不是与节点绑定，而是与插槽绑定。redis回根据key的有小部分计算插槽，分两种情况：</p>
<ul>
<li>kay中包含”{}”，且”{}”中至少包含1个字符，”{}”中的部分是有效部分</li>
<li>key中不包含”{}”，整个key都是有效部分</li>
</ul>
<p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值</p>
<h5 id="Redis判断key与实例的对应关系"><a href="#Redis判断key与实例的对应关系" class="headerlink" title="Redis判断key与实例的对应关系"></a>Redis判断key与实例的对应关系</h5><ul>
<li>将16384个插槽分配给不同的实例</li>
<li>根据key的有效部分计算哈希值，对16384取余</li>
<li>余数作为插槽，寻找插槽所在实例即可</li>
</ul>
<h5 id="将一类数据固定保存到同一个Redis实例的方式"><a href="#将一类数据固定保存到同一个Redis实例的方式" class="headerlink" title="将一类数据固定保存到同一个Redis实例的方式"></a>将一类数据固定保存到同一个Redis实例的方式</h5><ul>
<li>这一类数据使用相同的有效部分，例如key都以{key_prfiex}为前缀</li>
</ul>
<h4 id="集群伸缩"><a href="#集群伸缩" class="headerlink" title="集群伸缩"></a>集群伸缩</h4><p>Redis-cli –cluster提供了很多操作集群的命令</p>
<h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>当集群中有一个master宕机：</p>
<ol>
<li>首先是该实例与其他实例失去连接</li>
<li>然后疑似宕机</li>
<li>最后确定下线，自动提升一个slave为新的master</li>
</ol>
<h5 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h5><p>利用cluster failvoer命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。流程如下：</p>
<img src="/2023/09/18/redis/shujuqianyi.png" alt="shujuqianyi" style="zoom:50%;">

<p>手动的Failover支持三种不同模式：</p>
<ul>
<li>缺省：默认的流程，如图1~6步</li>
<li>force：省略了对offset的一致性校验</li>
<li>takeover：直接执行第五步，忽略数据一致性、忽略master状态和其他master的意见</li>
</ul>
<h4 id="RedisTemplate访问分片集群"><a href="#RedisTemplate访问分片集群" class="headerlink" title="RedisTemplate访问分片集群"></a>RedisTemplate访问分片集群</h4><p>RedisTemplate底层同样给予lettuce实现了分片集群的访问，而使用的步骤与哨兵模式基本一致：</p>
<ol>
<li>引入redis的starter依赖</li>
<li>配置分片集群地址</li>
<li>配置读写分离</li>
</ol>
<p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p>
<figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spirng:</span></span><br><span class="line">	<span class="attr">redis:</span></span><br><span class="line">		<span class="attr">cluster:</span></span><br><span class="line">			<span class="attr">nodes:</span> <span class="comment"># 指定分片集群的每一个节点信息</span></span><br><span class="line">				<span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7001</span></span><br><span class="line">				<span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7002</span></span><br><span class="line">				<span class="bullet">-</span> <span class="number">192.168</span><span class="number">.150</span><span class="number">.101</span><span class="string">:7003</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="多级缓存"><a href="#多级缓存" class="headerlink" title="多级缓存"></a>多级缓存</h3><h4 id="传统缓存的问题"><a href="#传统缓存的问题" class="headerlink" title="传统缓存的问题"></a>传统缓存的问题</h4><p>传统的缓存策略一般是请求到达Tomcat后，先查询Redis，如果未命中则查询数据库，存在以下问题：</p>
<ul>
<li>请求要经过Tomcat处理，Tomcat的性能成为整个系统的瓶颈</li>
<li>Redis缓存失效时，会对数据库产生冲击</li>
</ul>
<h4 id="多级缓存方案"><a href="#多级缓存方案" class="headerlink" title="多级缓存方案"></a>多级缓存方案</h4><p>多级缓存就是充分利用请求处理的各个环节，分别添加缓存，减轻Tomcat压力，提升服务性能</p>
<p>用作缓存的Nginx是业务Nginx，需要部署为集群，再有专门的Nginx用来做反向代理</p>
<img src="/2023/09/18/redis/duojihuancun.png" alt="duojihuancun" style="zoom:67%;">
</body></html>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaWeb/" rel="tag"># JavaWeb</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/09/14/dataStruct/" rel="prev" title="dataStruct">
      <i class="fa fa-chevron-left"></i> dataStruct
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/09/18/JUC/" rel="next" title="JUC">
      JUC <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">Redis基础使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NoSQL%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">NoSQL特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">Redis特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">Redis数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">1.4.</span> <span class="nav-text">Redis通用命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.</span> <span class="nav-text">String类型命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#key%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.</span> <span class="nav-text">key的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4"><span class="nav-number">1.7.</span> <span class="nav-text">Hash类型命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.8.</span> <span class="nav-text">List类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.9.</span> <span class="nav-text">Set类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SortedSet%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.10.</span> <span class="nav-text">SortedSet类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jedis"><span class="nav-number">1.11.</span> <span class="nav-text">Jedis</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringDataRedis"><span class="nav-number">1.12.</span> <span class="nav-text">SpringDataRedis</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringDataRedis%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8"><span class="nav-number">1.12.1.</span> <span class="nav-text">SpringDataRedis快速使用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="nav-number">1.12.1.1.</span> <span class="nav-text">引入依赖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">1.12.1.2.</span> <span class="nav-text">配置文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5RedisTemplate"><span class="nav-number">1.12.1.3.</span> <span class="nav-text">注入RedisTemplate</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SpringDataRedis%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">1.12.2.</span> <span class="nav-text">SpringDataRedis的序列化方式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E6%88%98"><span class="nav-number">2.</span> <span class="nav-text">实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Session%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="nav-number">2.1.</span> <span class="nav-text">Session实现用户短信登录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">2.2.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="nav-number">2.2.1.</span> <span class="nav-text">缓存的简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0Redis%E7%BC%93%E5%AD%98"><span class="nav-number">2.2.2.</span> <span class="nav-text">添加Redis缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">2.2.3.</span> <span class="nav-text">缓存更新策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">2.2.4.</span> <span class="nav-text">主动更新策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">2.2.5.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">2.2.6.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">2.2.7.</span> <span class="nav-text">缓存击穿</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">2.3.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">2.3.1.</span> <span class="nav-text">乐观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS%E6%B3%95"><span class="nav-number">2.3.1.1.</span> <span class="nav-text">CAS法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">2.3.2.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">基于Redis的分布式锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E8%BF%9BRedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">改进Redis的分布式锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E7%9A%84Lua%E8%84%9A%E6%9C%AC"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">Redis的Lua脚本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redisson"><span class="nav-number">2.4.</span> <span class="nav-text">Redisson</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE"><span class="nav-number">2.4.1.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redisson%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.4.2.</span> <span class="nav-text">Redisson可重入锁的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.4.3.</span> <span class="nav-text">Redisson分布式的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.4.</span> <span class="nav-text">Redisson分布式锁主从一致性问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">2.5.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EList%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">2.5.1.</span> <span class="nav-text">基于List结构模拟消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">2.5.1.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">2.5.1.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EPubSub%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">2.5.2.</span> <span class="nav-text">基于PubSub的消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-1"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">2.5.3.</span> <span class="nav-text">基于Stream的消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">2.5.3.1.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="nav-number">2.5.4.</span> <span class="nav-text">基于Stream的消息队列-消费者组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-1"><span class="nav-number">2.5.4.1.</span> <span class="nav-text">特点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GEO%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">2.6.</span> <span class="nav-text">GEO数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BitMap"><span class="nav-number">2.7.</span> <span class="nav-text">BitMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HyperLogLog%E7%94%A8%E6%B3%95"><span class="nav-number">2.8.</span> <span class="nav-text">HyperLogLog用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="nav-number">2.9.</span> <span class="nav-text">分布式缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96"><span class="nav-number">2.9.1.</span> <span class="nav-text">Redis持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RDB"><span class="nav-number">2.9.1.1.</span> <span class="nav-text">RDB</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RDB%E6%96%B9%E5%BC%8Fbgsave%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">2.9.1.1.1.</span> <span class="nav-text">RDB方式bgsave的执行流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDB%E7%9A%84%E6%89%A7%E8%A1%8C%E6%97%B6%E6%9C%BA"><span class="nav-number">2.9.1.1.2.</span> <span class="nav-text">RDB的执行时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDB%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="nav-number">2.9.1.1.3.</span> <span class="nav-text">RDB的缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF"><span class="nav-number">2.9.1.2.</span> <span class="nav-text">AOF</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E6%AF%94"><span class="nav-number">2.9.1.2.1.</span> <span class="nav-text">对比</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84"><span class="nav-number">2.9.2.</span> <span class="nav-text">主从架构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="nav-number">2.9.2.0.1.</span> <span class="nav-text">数据同步原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">2.9.2.0.2.</span> <span class="nav-text">全量同步的原理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">2.9.2.0.3.</span> <span class="nav-text">全量同步与增量同步的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5%E6%97%B6%E6%9C%BA"><span class="nav-number">2.9.2.0.4.</span> <span class="nav-text">执行全量同步时机</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%A2%9E%E9%87%8F%E5%90%8C%E6%AD%A5%E6%97%B6%E6%9C%BA"><span class="nav-number">2.9.2.0.5.</span> <span class="nav-text">执行增量同步时机</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%93%A8%E5%85%B5"><span class="nav-number">2.9.3.</span> <span class="nav-text">Redis哨兵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">2.9.3.1.</span> <span class="nav-text">哨兵的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81%E7%9B%91%E6%8E%A7"><span class="nav-number">2.9.3.2.</span> <span class="nav-text">服务状态监控</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%80%89%E4%B8%BE%E6%96%B0%E7%9A%84master"><span class="nav-number">2.9.3.3.</span> <span class="nav-text">选举新的master</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="nav-number">2.9.3.4.</span> <span class="nav-text">实现故障转移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Sentinel%E7%9A%84%E4%B8%89%E4%B8%AA%E4%BD%9C%E7%94%A8"><span class="nav-number">2.9.3.5.</span> <span class="nav-text">Sentinel的三个作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RedisTemplate%E7%9A%84%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.9.3.6.</span> <span class="nav-text">RedisTemplate的哨兵模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="nav-number">2.9.4.</span> <span class="nav-text">Redis分片集群</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%A3%E5%88%97%E6%8F%92%E6%A7%BD"><span class="nav-number">2.9.4.1.</span> <span class="nav-text">散列插槽</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Redis%E5%88%A4%E6%96%ADkey%E4%B8%8E%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="nav-number">2.9.4.1.1.</span> <span class="nav-text">Redis判断key与实例的对应关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B0%86%E4%B8%80%E7%B1%BB%E6%95%B0%E6%8D%AE%E5%9B%BA%E5%AE%9A%E4%BF%9D%E5%AD%98%E5%88%B0%E5%90%8C%E4%B8%80%E4%B8%AARedis%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">2.9.4.1.2.</span> <span class="nav-text">将一类数据固定保存到同一个Redis实例的方式</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9B%86%E7%BE%A4%E4%BC%B8%E7%BC%A9"><span class="nav-number">2.9.4.2.</span> <span class="nav-text">集群伸缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="nav-number">2.9.4.3.</span> <span class="nav-text">故障转移</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB"><span class="nav-number">2.9.4.3.1.</span> <span class="nav-text">数据迁移</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RedisTemplate%E8%AE%BF%E9%97%AE%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4"><span class="nav-number">2.9.4.4.</span> <span class="nav-text">RedisTemplate访问分片集群</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98"><span class="nav-number">2.9.5.</span> <span class="nav-text">多级缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%BC%93%E5%AD%98%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">2.9.5.1.</span> <span class="nav-text">传统缓存的问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88"><span class="nav-number">2.9.5.2.</span> <span class="nav-text">多级缓存方案</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MANVND</p>
  <div class="site-description" itemprop="description">There is no royal road to learning</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MANVND</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
