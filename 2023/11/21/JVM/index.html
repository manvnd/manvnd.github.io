<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="JVM">
<meta property="og:url" content="http://example.com/2023/11/21/JVM/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/JVMCompare.png">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/MethodAreaStruct.png">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/FileRead01.png">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/FileRead02.png">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/Mark-Sweep.png">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/Mark-Compact.png">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/Mark-Copy.png">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/GenerationCollection.png">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/Serial.png">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/Parallel.png">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/G1Sequence.png">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/BrooksPointer.png">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/ShenandoahSequence.png">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/ColoredPointer.png">
<meta property="og:image" content="http://example.com/2023/11/21/JVM/ZGCSequence.png">
<meta property="article:published_time" content="2023-11-21T08:38:54.000Z">
<meta property="article:modified_time" content="2023-12-05T07:04:12.143Z">
<meta property="article:author" content="MANVND">
<meta property="article:tag" content="JavaWeb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/11/21/JVM/JVMCompare.png">

<link rel="canonical" href="http://example.com/2023/11/21/JVM/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>JVM | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/21/JVM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MANVND">
      <meta itemprop="description" content="There is no royal road to learning">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JVM
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-21 16:38:54" itemprop="dateCreated datePublished" datetime="2023-11-21T16:38:54+08:00">2023-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-12-05 15:04:12" itemprop="dateModified" datetime="2023-12-05T15:04:12+08:00">2023-12-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <html><head></head><body><h1 id="JVM基本介绍"><a href="#JVM基本介绍" class="headerlink" title="JVM基本介绍"></a>JVM基本介绍</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>Java Virtual Machine - java程序运行环境（java二进制字节码的运行环境）</p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li><p>  一次编写，多处运行</p>
</li>
<li><p>  自动内存管理，垃圾回收功能</p>
</li>
<li><p>  数组下标越界检查</p>
</li>
<li><p>  多态</p>
</li>
</ul>
<h2 id="比较JVM、JRE、JDK"><a href="#比较JVM、JRE、JDK" class="headerlink" title="比较JVM、JRE、JDK"></a>比较JVM、JRE、JDK</h2><img src="/2023/11/21/JVM/JVMCompare.png" alt="JVMCompare" style="zoom: 25%;">

<p>JVM：Java Virtual Machine</p>
<p>JRE：Java Runtime Environment</p>
<p>JDK：Java Develop Kit</p>
<h1 id="JVM内存结构"><a href="#JVM内存结构" class="headerlink" title="JVM内存结构"></a>JVM内存结构</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>Program Counter Register程序计数器（寄存器）</p>
<ul>
<li>  作用：<strong>记录下一条JVM指令的执行地址</strong></li>
<li>特点：<ul>
<li>  是线程私有的</li>
<li>  不会存在内存溢出</li>
</ul>
</li>
</ul>
<p>如果线程正在执行一个Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是本地方法，这个计数器值为空</p>
<h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>Java Virtual Machine Stacks（java虚拟机栈）</p>
<ul>
<li>  每个线程运行时所需要的内存，称为虚拟机栈</li>
<li>  每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li>
<li>  每个线程只能有一个活动栈帧（栈顶部的栈帧），对应着当前正在执行的那个方法</li>
</ul>
<p>问题辨析：</p>
<ol>
<li>  垃圾回收是否涉及栈内存？不会，因为栈帧出栈后就会被释放</li>
<li>  栈内存的分配越大越好吗？不是，如果栈内存过大会浪费过多内存并且会减少线程的数量；可以通过-Xss设置栈大小</li>
<li>  方法内的局部变量是否线程安全？<strong>不逃逸方法作用范围的局部变量才是线程安全的</strong></li>
</ol>
<p><strong>栈帧由局部变量、方法参数、返回地址等组成</strong></p>
<h3 id="栈内存溢出"><a href="#栈内存溢出" class="headerlink" title="栈内存溢出"></a>栈内存溢出</h3><ul>
<li>  栈帧过多导致栈溢出——如递归调用</li>
<li>  栈帧过大导致栈内存溢出</li>
</ul>
<p>栈内存溢出异常——StackOverflowError</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法使用的内存、即native方法，通过其他语言实现的方法称为本地方法，Hotspot不区分本地方法栈与虚拟机栈，都在一个栈中</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>Heap 堆</p>
<ul>
<li>  通过new关键字，创建对象都会使用堆内存</li>
</ul>
<p>特点</p>
<ul>
<li>  它是<strong>线程共享</strong>的，堆中对象都需要考虑线程安全的问题</li>
<li>  有垃圾回收机制</li>
</ul>
<p>可以使用-Xmx控制堆内存大小</p>
<p>堆溢出会抛出：OutOfMemoryError异常</p>
<h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>所有Java<strong>线程共享</strong>的区，存储跟类的结构相关的信息，包括域、方法信息、构造方法信息以及运行时常量池。方法区在虚拟机启动时创建，方法区逻辑上是堆的组成部分</p>
<img src="/2023/11/21/JVM/MethodAreaStruct.png" alt="MethodAreaStruct" style="zoom: 33%;">

<p>Hotsopt实现方法区方式，1.6之前：方法区与堆在一起，称为永久代；1.6之后：方法区在内存中，称为元空间，但是串池移到堆中</p>
<h3 id="方法区内存溢出"><a href="#方法区内存溢出" class="headerlink" title="方法区内存溢出"></a>方法区内存溢出</h3><ul>
<li>  1.8以前会导致永久代内存溢出</li>
<li>  1.8之后会导致元空间内存溢出</li>
</ul>
<p>方法区溢出也会抛出：OutOfMemoryError异常</p>
<p>场景：</p>
<ul>
<li>  spring</li>
<li>  mybatis                                                                                                                                                                                                                                                   </li>
</ul>
<h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><ul>
<li>  常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li>
<li>  运行时常量池，常量池*.class文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li>
</ul>
<p>常量池在编译后的.class文件中，运行时常量池在方法区（永久代或元空间）中</p>
<p>因为运行时常量池也是方法区的一部分，所以受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError异常</p>
<h2 id="串池"><a href="#串池" class="headerlink" title="串池"></a>串池</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>StringTable，1.8以前在永久代中，1.8以后在堆中</p>
<ul>
<li>  常量池中的字符串仅是符号，第一次用到才会变为对象</li>
<li>  利用串池的机制，来避免重复创建字符串对象</li>
<li>  字符串变量拼接的原理是StringBuilder</li>
<li>  字符串常量拼接的原理是编译期优化</li>
<li>可以使用intern方法，主动将串池中还没有的字符串放入串池<ul>
<li>  1.8将这个字符串对象尝试放入串池，如果有则不会放入，如果没有放入串池，会把串池中的对象返回</li>
<li>  1.6将这个字符串对象尝试放入串池，如果有则不会放入，如果没有放入串池，会把此对象复制一份，放入串池，然后返回串池对象</li>
</ul>
</li>
</ul>
<p>底层实现是哈希表</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"a"</span>; <span class="comment">// 需要时加载到内存，并放入串池，懒加载</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"b"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">"a"</span> + <span class="string">"b"</span>; <span class="comment">// ldc "ab"</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2; <span class="comment">// new StringBuilder().append(s1).append(s2).toString() new String(value) 故s4在堆中，s1和s2是变量，编译期间不能确定值，使用StringBuilder创建</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">"ab"</span>; <span class="comment">// ldc "ab" javac在编译期间的优化，结果已经在编译期间确定为"ab"</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s4.intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4); <span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s5); <span class="comment">// true</span></span><br><span class="line">System.out.println(s3 == s6); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">x2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"c"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"d"</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="string">"cd"</span>;</span><br><span class="line">x3 = x2.intern();</span><br><span class="line">System.out.println(x1 == x2); <span class="comment">// false(1.8) true(1.6)</span></span><br><span class="line">System.out.println(x1 == x3); <span class="comment">// true</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>JDK（1.8以前）串池在运行时常量池中，即永久代中</p>
<p>JDK（1.8以后）串池在堆中，即元空间中</p>
<h3 id="StringTable垃圾回收"><a href="#StringTable垃圾回收" class="headerlink" title="StringTable垃圾回收"></a>StringTable垃圾回收</h3><p>当StringTable空间不够时，就会触发垃圾回收，将没有被引用的字符串对象释放</p>
<h3 id="StringTable性能调优"><a href="#StringTable性能调优" class="headerlink" title="StringTable性能调优"></a>StringTable性能调优</h3><ul>
<li><p>  可以通过-XX:StringTableSize=1010来修改StringTable的桶大小，适当调整StringTable的桶大小可以有效提高性能</p>
</li>
<li><p>  考虑是否将字符串入池</p>
</li>
</ul>
<h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>Direct Memory</p>
<ul>
<li>  常见于NIO操作，用于数据缓冲区</li>
<li>  分配回收成本较高，但读写性能高</li>
<li>  不受JVM内存回收管理</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><img src="/2023/11/21/JVM/FileRead01.png" alt="FileRead01" style="zoom: 50%;">

<p>上图是正常情况下Java读取文件过程，操作系统将磁盘文件读取到系统内存，然后Java将系统内存中系统缓冲区的文件读取到Java缓冲区</p>
<img src="/2023/11/21/JVM/FileRead02.png" alt="FileRead02" style="zoom:50%;">

<p>上图是使用直接内存读取图片的情况，Java可以直接从系统内存中读取数据</p>
<ul>
<li>  直接内存使用了Unsafe对象完成直接内存的分配和回收，并且回收需要主动调用freeMemory方法</li>
<li>  ByteBuffer的实现类内部，使用了Cleaner（虚引用）来监测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会由ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存</li>
</ul>
<p>除了用System.gc显式垃圾回收，也可以使用Unsafe来进行内存释放</p>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="如何判断对象可以回收"><a href="#如何判断对象可以回收" class="headerlink" title="如何判断对象可以回收"></a>如何判断对象可以回收</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>每个对象记录一个引用计数，表示有多少引用指向该对象。当引用计数为零时，说明该对象没有被引用，即成为垃圾，可以被回收。</p>
<p>但是对于循环引用的对象，无法垃圾回收</p>
<h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><ul>
<li>  Java虚拟机中的垃圾回收期采用可达性分析来探索所有存活的对象</li>
<li>  扫描堆中的对象，看是否能沿着GC Root对象为起点的引用链找到该对象，找不到，表示可以回收</li>
</ul>
<p>可以作为GC Root对象的有：</p>
<ul>
<li>  虚拟机栈中的引用</li>
<li>  方法区中的静态变量引用</li>
<li>  方法区中的常量引用</li>
<li>  本地方法栈中的引用</li>
</ul>
<h3 id="五种引用"><a href="#五种引用" class="headerlink" title="五种引用"></a>五种引用</h3><ol>
<li><p>强引用</p>
<ul>
<li>  只有所有GC Root对象都不通过【强引用】引用该对象，该对象才能被垃圾回收</li>
</ul>
</li>
<li><p>软引用——SoftReference&lt;T&gt;</p>
<ul>
<li><p>  仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收，回收软引用对象</p>
</li>
<li><p>可以配合引用队列来释放软引用自身</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示软引用，配合引用队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_4</span> {</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 引用队列</span></span><br><span class="line">        ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="comment">// 关联了引用队列，当软引用所关联的byte[]被回收时，软引用自己会加入queue中</span></span><br><span class="line">            SoftReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB], queue);</span><br><span class="line">            System.out.println(Arrays.toString(ref.get()));</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从队列中获取无用的软引用并移除</span></span><br><span class="line">        Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">        <span class="keyword">while</span> (poll != <span class="literal">null</span>) {</span><br><span class="line">            list.remove(poll);</span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; reference : list) {</span><br><span class="line">            System.out.println(Arrays.toString(reference.get()));</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>


</li>
</ul>
</li>
<li><p>弱引用</p>
<ul>
<li><p>  仅有弱引用引用该对象时，在垃圾回收时，无论内存充足与否，都会回收弱引用对象</p>
</li>
<li><p>可以配合引用队列来释放弱引用本身</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示弱引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2_5</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4MB</span> <span class="operator">=</span> <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// list --&gt; WeakReference --&gt; byte[]</span></span><br><span class="line">        List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 引用队列</span></span><br><span class="line">        ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            <span class="comment">// 关联了引用队列，当软引用所关联的byte[]被回收时，软引用自己会加入queue中</span></span><br><span class="line">            WeakReference&lt;<span class="type">byte</span>[]&gt; ref = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4MB], queue);</span><br><span class="line">            list.add(ref);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 从队列中获取无用的软引用并移除</span></span><br><span class="line">        Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll();</span><br><span class="line">        <span class="keyword">while</span> (poll != <span class="literal">null</span>) {</span><br><span class="line">            list.remove(poll);</span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span> (WeakReference&lt;<span class="type">byte</span>[]&gt; reference : list) {</span><br><span class="line">            System.out.println(Arrays.toString(reference.get()));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li><p>虚引用</p>
<ul>
<li>  必须配合引用队列使用，主要配合ByteBuffer使用，在引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存，ByteBuffer与Cleaner</li>
</ul>
</li>
<li><p>终结器引用</p>
<ul>
<li>  无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由Finalizer线程通过终结器引用找到被引用对象并调用它的finalize方法，第二次GC时才能回收被引用对象</li>
</ul>
</li>
</ol>
<h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><img src="/2023/11/21/JVM/Mark-Sweep.png" alt="Mark-Sweep" style="zoom:50%;">

<p>分为两阶段，首先标记处需要回收的对象，在标记完成后，统一回收所有未被标记的对象。</p>
<p>缺点：</p>
<ul>
<li>  随着对象的增多，标记和清除的开销变大</li>
<li>  系统内存的碎片化</li>
</ul>
<h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><img src="/2023/11/21/JVM/Mark-Compact.png" alt="Mark-Compact" style="zoom:50%;">

<p>标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清除，而是让所有存活的对象都向内存空间的一端移动，然后直接清理掉边界外的内存</p>
<p>缺点</p>
<ul>
<li>  速度较慢</li>
</ul>
<p>优点</p>
<ul>
<li>  没有内存碎片</li>
</ul>
<h3 id="标记-复制"><a href="#标记-复制" class="headerlink" title="标记-复制"></a>标记-复制</h3><img src="/2023/11/21/JVM/Mark-Copy.png" alt="Mark-Copy" style="zoom:50%;">

<p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块的内存用完了，就将还存活着的对象复制到另一块上，然后将已使用过的内存清空</p>
<p>优点</p>
<ul>
<li>  不会有内存碎片</li>
</ul>
<p>缺点</p>
<ul>
<li>  需要占用双倍的内存空间</li>
</ul>
<h3 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h3><img src="/2023/11/21/JVM/GenerationCollection.png" alt="GenerationCollection" style="zoom:50%;">

<ul>
<li>  对象首先分配在伊甸园区</li>
<li>  新生代空间不足时，出发Minor GC，伊甸园和From存活的对象复制到to中，存活的对象年龄加1，并且交换From和To</li>
<li>  Minor GC会引发“Stop The World”——暂停其他用户的线程，等垃圾回收结束，用户线程才恢复运行</li>
<li>  当对象寿命超过阈值，会晋升至老年代，最大寿命是15（4bit）</li>
<li>  当老年代空间不足，会先尝试触发Minor GC，如果之后空间仍不足，那么触发Full GC，STW的时间更长</li>
<li>  如果老年代空间仍不足，那么抛出OutOfMemoryError</li>
<li>  对于超过新生代空间的大对象会直接晋升至老年代</li>
<li>  新生代中的空间实在不足也会触发提前晋升</li>
</ul>
<h4 id="相关VM参数"><a href="#相关VM参数" class="headerlink" title="相关VM参数"></a>相关VM参数</h4><table>
<thead>
<tr>
<th>含义</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>堆初始大小</td>
<td>-Xms</td>
</tr>
<tr>
<td>堆最大大小</td>
<td>-Xms或-XX:MaxHeapSize=size</td>
</tr>
<tr>
<td>新生代大小</td>
<td>-Xmn或(-XX:NewSize=size+ -XX:MaxNewSize=size)</td>
</tr>
<tr>
<td>幸存区比例（动态）</td>
<td>-XX:InitialSurvivorRatio=ration 和 -XX:+UseAdaptiveSizePolicy</td>
</tr>
<tr>
<td>幸存区比例</td>
<td>-XX:SurvivorRatio=ratio</td>
</tr>
<tr>
<td>晋升阈值</td>
<td>-XX:MaxTenuringThreshold=threshold</td>
</tr>
<tr>
<td>晋升详情</td>
<td>-XX:+PrintTenuringDistribution</td>
</tr>
<tr>
<td>GC详情</td>
<td>-XX:+PrintGCDetails -verbose:gc</td>
</tr>
<tr>
<td>FullGC前MinorGC</td>
<td>-XX:+ScavengeBeforeFullGC</td>
</tr>
</tbody></table>
<h2 id="经典垃圾回收器"><a href="#经典垃圾回收器" class="headerlink" title="经典垃圾回收器"></a>经典垃圾回收器</h2><h3 id="串行"><a href="#串行" class="headerlink" title="串行"></a>串行</h3><ul>
<li>  单线程</li>
<li>  堆内存较小，适合个人电脑</li>
</ul>
<p>开启参数：-XX:+UseSerialGC=Serial+SerialOld</p>
<p>Serial工作在新生代，采用“复制”算法，SerialOld工作在老年代，采用“标记-整理”算法</p>
<img src="/2023/11/21/JVM/Serial.png" alt="Serial" style="zoom:50%;">

<h3 id="吞吐量优先"><a href="#吞吐量优先" class="headerlink" title="吞吐量优先"></a>吞吐量优先</h3><ul>
<li>  多线程</li>
<li>  堆内存较大，多核CPU</li>
<li>  单位时间内，“Stop The World”时间最短</li>
</ul>
<p>开启参数：</p>
<ul>
<li>  -XX:+UseParallelGC~ -XX:+UseParallelOldGC 前者工作在新生代，采用“复制“算法，后者工作在老年代，采用“标记-整理”算法，开启一个会自动开启另一个</li>
<li>  -XX:+UseAdaptiveSizePolicy 采用自适应调整新生代大小策略</li>
<li>  -XX:GCTimeRatio=ratio $rate=1/(1+radio)$ 调整堆的大小使垃圾回收时间占比不超过ratio</li>
<li>  -XX:MaxGCPauseMillis=ms 调整堆大小使垃圾回收时间不超过该参数</li>
<li>  -XX:ParallelGCThreads=n 控制垃圾回收线程的数量</li>
</ul>
<p><img src="/2023/11/21/JVM/Parallel.png" alt="Parallel"></p>
<h3 id="响应时间优先"><a href="#响应时间优先" class="headerlink" title="响应时间优先"></a>响应时间优先</h3><ul>
<li>  多线程</li>
<li>  堆内存较大，多核CPU</li>
<li>  让单次“Stop The World”时间尽可能短</li>
</ul>
<p>开启参数：</p>
<p>-XX:+UseConcMarkSweepGC ~ -XX:UseParNewGC ~ SerialOld 前者工作</p>
<p>-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads</p>
<p>-XX:CMSInitiatingOccupancyFraction=percent</p>
<p>-XX:+CMSScavengeBeforeRemark</p>
<h3 id="G1（Garbage-First）"><a href="#G1（Garbage-First）" class="headerlink" title="G1（Garbage First）"></a>G1（Garbage First）</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>G1收集器是一款“停顿预测模型”的收集器，即能够支持在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的事件大概率不超过N毫秒</p>
<h4 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h4><p>G1将连续的Java堆划分为多个大小相等的独立区域（Region），每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间或者老年代空间</p>
<p>Region中有一类特殊的Humongous空间，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。每个Region的大小可以通过参数 -XX:G1HeapRegionSize 设定，取值范围为 1MB~2MB，且应为2的N次幂。而对于超过了整个Region容量的大对象，会被存放在连续的N个Humongous Region中，G1的大多数行为都将Humongous Region作为老年代的一部分进行看待</p>
<h4 id="记忆集"><a href="#记忆集" class="headerlink" title="记忆集"></a>记忆集</h4><p>G1将java堆分为若干个独立的Region后，解决跨代引用的方式仍是记忆集，G1为每个Region维护一个记忆集，这些记忆集回记录下别的Region指向自己的指针，并标记这些指针分别在哪些卡页的范围之内；因为Region的数量很多，因此记忆集占据的内存空间也很庞大</p>
<h4 id="并发标记阶段的不一致解决方法"><a href="#并发标记阶段的不一致解决方法" class="headerlink" title="并发标记阶段的不一致解决方法"></a>并发标记阶段的不一致解决方法</h4><p>G1通过原始快照（SATB）算法解决此问题；此外，对于回收过程中用户线程新创建的对象内存分配上，G1为每个Region设计了两个名为TAMS（Top at Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中的新对象分配，并发回收时新分配的对象地址都必须要在这两个指针位置以上。G1收集器默认在这个地址以上的对象是被隐式标记过的，即默认它们是存活的，不纳入回收范围。</p>
<h4 id="停顿预测模型的建立"><a href="#停顿预测模型的建立" class="headerlink" title="停顿预测模型的建立"></a>停顿预测模型的建立</h4><p>用户通过 -XX:MaxGCPauseMillis参数指定的停顿时间是垃圾收集发生之前的期望值。G1收集器的停顿预测模型是以衰减均值为理论基础来实现的，在垃圾收集过程中，G1收集器回记录每个Region的回收耗时、每个Region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值、标准偏差、置信度等统计信息。“衰减平均值”指它会比普通的平均值更容易受到新数据的影响，衰减平均值更准确地代表了“最近的”平均状态。因为，Region的统计状态越新越能决定其回收的价值。然后通过这些信息预测现在开始回收的话，由哪些Region组成回收集才可以在不超过期望停顿时间的约束下获得最高手机</p>
<h4 id="运行步骤"><a href="#运行步骤" class="headerlink" title="运行步骤"></a>运行步骤</h4><img src="/2023/11/21/JVM/G1Sequence.png" alt="G1Sequence" style="zoom:50%;">

<ol>
<li>  初始标记（Initial Marking）（STW）：仅仅标记GC Roots能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。</li>
<li>  并发标记（Concurrent Marking）：从GC Roots开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象</li>
<li>  最终标记（Final Marking）（STW）：暂停用户线程，处理并发标记阶段结束后遗留下来的那些SATB记录</li>
<li>  筛选回收（Liva Data Counting and Evacuation）（STW）：对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收策略，可以自由选择任意多个Region构成回收集，然后把决定回收的哪一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作设计对象的移动，故要暂停用户线程</li>
</ol>
<h2 id="低延时垃圾收集器"><a href="#低延时垃圾收集器" class="headerlink" title="低延时垃圾收集器"></a>低延时垃圾收集器</h2><h3 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Shenandoah是由Red Hat开发的一款<strong>低延迟</strong>的垃圾收集器，Shenandoah并发执行大部分GC工作，包括并发的整理，堆大小对STW的时间基本没有影响</p>
<ul>
<li>  Shenandoah不再区分新生代和老年代</li>
<li>  Shenandoah使用连接矩阵代替G1中的卡表</li>
</ul>
<h4 id="连接矩阵"><a href="#连接矩阵" class="headerlink" title="连接矩阵"></a>连接矩阵</h4><p>一个二维数组，如果Region A中有对象指向Region B中的对象，那么在数组的第A行第B列打上标记；相较于记忆集，粒度更大，但是占用资源更少</p>
<h4 id="转发指针"><a href="#转发指针" class="headerlink" title="转发指针"></a>转发指针</h4><p>在对象头前面增加一个新的引用字段，在非并发移动情况下指向自己，产生新对象后指向新对象。当访问一个对象时，需要先访问转发指针看其指向哪里</p>
<img src="/2023/11/21/JVM/BrooksPointer.png" alt="BrooksPointer" style="zoom:50%;">

<p>问题：</p>
<ol>
<li>  修改时的<strong>线程安全问题</strong>：对象增加了一个转发指针，这个指针的修改和对象本身的修改就存在线程安全问题。如复制新对象之后，转发指针修改之前发生了旧对象的修改，这就存在两个对象不一致的问题。Shenandoah采用<strong>CAS</strong>操作来保证修改的正确性</li>
<li>  转发指针的加入需要覆盖所有涉及对象访问的场景，包括读、写、加锁等等，所以需要同时设置读屏障和写屏障。有其读操作相较于写操作出现的频率更高，这样高频操作带来的性能问题影响巨大。故在JDK13之后，Shenandoah将内存屏障改为引用访问屏障，即仅仅在对象的引用类型的读写操作增加屏障，而不管原生对象的操作，省去了大量的对象访问操作</li>
</ol>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="/2023/11/21/JVM/ShenandoahSequence.png" alt="ShenandoahSequence"></p>
<ol>
<li><p>  初始标记（Initial Marking）（STW）：标记与GC Roots直接关联的对象</p>
</li>
<li><p>  并发标记（Concurrent Marking）：遍历对象图，标记全部可达对象，与用户线程并发</p>
</li>
<li><p>  最终标记（Final Marking）（STW）：处理剩余的STAB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组<strong>回收集</strong></p>
</li>
<li><p>  并发清理（Concurrent Cleanup）：清理那些一个存活对象都没有的Region（Immediate Garbage Region）</p>
</li>
<li><p>  并发回收（Concurrent Evacuation）：Shenandoah把回收集里的存活对象复制一份到其他的未使用的Region中，此过程是并发执行的，因此会出现旧对象与新对象的读写不一致问题，Shenandoah采用转发指针解决此问题</p>
</li>
<li><p>  初始引用更新（Initial Update Reference）（STW）：把堆中所有指向旧对象的引用修正到新对象上，称为“引用更新”。没有实际操作，只是为了设置一个阻塞点来保证上述并发操作完成</p>
</li>
<li><p>  并发引用更新（Concurrent Update Reference）：按照内存物理地址的顺序，顺序搜索出引用类型，将旧值修改为新值</p>
</li>
<li><p>  最终引用更新（Final Update Reference）（STW）：解决堆中的引用更新后，还需要修改GC Roots的引用</p>
</li>
<li><p>  并发清理（Concurrent Cleanup）：清理回收集中的所有Region</p>
</li>
</ol>
<h3 id="ZGC收集器"><a href="#ZGC收集器" class="headerlink" title="ZGC收集器"></a>ZGC收集器</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>ZGC是Oracle官方研发并于JDK11引入，并于JDK15中作为生产就绪使用，其设计之初定义了三大目标：</p>
<ol>
<li>  支持TB级内存</li>
<li>  停顿控制在10ms以内，且不随着堆大小增加而增加</li>
<li>  对程序吞吐量影响小于15%</li>
</ol>
<h4 id="内存布局-1"><a href="#内存布局-1" class="headerlink" title="内存布局"></a>内存布局</h4><p>ZGC与G1一样采用分区域（Region）的堆内存布局，区别是ZGC的Region可以动态创建和销毁，容量也可以动态调整</p>
<p>ZGC的Region分为三种：</p>
<ol>
<li>  小型Region容量固定为2MB，用于存放小于256KB的对象</li>
<li>  中型Region容量固定为32MB，用于存放大于等于256KB但不足4MB的对象</li>
<li>  大型Region容量为2MB的整数倍，存放4MB及以上大小的对象，而且每个大型Region中只存放一个大对象。由于大对象移动代价过大，所以该对象不会被重分配</li>
</ol>
<h4 id="重分配集"><a href="#重分配集" class="headerlink" title="重分配集"></a>重分配集</h4><p>G1中的回收集用来存放所有需要G1扫描的Region，而ZGC为了省去卡表的维护，标记过程会扫描所有Region，如果判定某个Region中的存活对象需要被重分配，那么就将该Region放入重分配集中</p>
<h4 id="染色指针"><a href="#染色指针" class="headerlink" title="染色指针"></a>染色指针</h4><p>64位机器指针是64位，Linux下64位高18位不能用来寻址，剩下的46位，ZGC选择其中4位用来辅助GC工作，另外42为能够支持最大内存为4T</p>
<p>ZGC在指针中增加了4个标志位，包括Finalizable、Remapped、Marked0和Marked1</p>
<img src="/2023/11/21/JVM/ColoredPointer.png" alt="ColoredPointer" style="zoom:50%;">

<p>Finalizable标识标识对象是否只能通过 <code>finalize()</code> 方法访问到，Remapped、Marked0和Marked1用作三色标记</p>
<p>既有M0又有M1的原因：ZGC标记完成后并不需要等待对象指针重新映射便可进行下一次垃圾回收循环，所以使用两个标记位分别用作两次相邻GC过程的标记，M0和M1交替使用</p>
<p>染色指针的<strong>自愈</strong>：ZGC会为分配集中的每个Region维护一个转发表（Forward Table），记录从旧对象到新对象的转向关系。根据染色指针的标志位，ZGC可以从引用上就知道一个对象是否处于重分配集，如果用户线程此时并发访问了位于重分配集中的对象，这次访问会被预置的内存屏障截取，并立刻根据Region上的转发表将访问转发到新复制的对象上，同时更新该引用，使其直接指向新对象</p>
<p>优点：</p>
<ol>
<li>  由于染色指针提供的“自愈能力”，当某个Region的存活对象被移走后，这个Region可以立即被释放和重用</li>
<li>  染色指针可以大幅减少垃圾收集过程中内存屏障的使用数量，因为ZGC不像Shenandoah在对象头前增加转发指针，减少了大量的并发写操作</li>
<li>  染色指针还有18位的前置寻址空间可以使用，扩展性十分强大</li>
</ol>
<h4 id="内存映射"><a href="#内存映射" class="headerlink" title="内存映射"></a>内存映射</h4><p>染色指针只是JVM定义的，操作系统、处理器未必支持。为了解决这个问题，ZGC在Linux/X86-64平台上采用了虚拟内存映射技术</p>
<p>ZGC为每个对象都创建了三个虚拟内存地址，分别对应Remapped、Marked0和Marked1，通过指针指向不同的虚拟内存地址来表示不同的染色标记</p>
<h4 id="NUMA（Non-Uniform-Memory-Access，非统一内存访问架构）"><a href="#NUMA（Non-Uniform-Memory-Access，非统一内存访问架构）" class="headerlink" title="NUMA（Non-Uniform Memory Access，非统一内存访问架构）"></a>NUMA（Non-Uniform Memory Access，非统一内存访问架构）</h4><p>多核CPU同时操作内存就会发生争抢，现代CPU会把内存控制系统器集成到处理器内核上，每个CPU核心都有属于自己的本地内存</p>
<p>在NUMA架构下，ZGC会先在自己的本地内存上分配对象，避免了对象使用的竞争</p>
<h4 id="ZGC运行步骤"><a href="#ZGC运行步骤" class="headerlink" title="ZGC运行步骤"></a>ZGC运行步骤</h4><img src="/2023/11/21/JVM/ZGCSequence.png" alt="ZGCSequence" style="zoom:67%;">

<ol>
<li>  并发标记（Concurrent Mark）（前后短暂STW）：对对象图做可达性分析的阶段，前后也要经历类似G1、Shenandoah的初始标记、最终标记的短暂停顿（STW），这些停顿阶段所做的内容也是类似的。与G1、Shenandoah不同的是，ZGC的标记在指针而不是在对象上进行，标记阶段会更新染色指针的Markded0和Marked1标志位</li>
<li>  并发预备重分配（Concurrent Prepare for Relocate）：根据特定的查询条件得出本次收集过程需要清理的Region，将这些Region组成重分配集</li>
<li>  并发重分配（Concurrent Relocate）：把重分配集中的存活对象复制到新的Region上，此过程如果涉及到并发读写不一致问题会被染色指针的自愈特性解决</li>
<li>  并发重映射（Concurrent Remap）：修正整个堆中指向重分配集中旧对象的所有引用，ZGC中的并发重映射不是一个必须要“迫切”去完成的任务，因为染色指针的自愈特性。重映射清理这些旧引用的主要目的是为了减少指针自愈的一次额外访问以及回收转发表的内存空间，ZGC将此阶段合并到了下一次垃圾回收循环中的并发标记阶段完成，反正它们都需要遍历所有对象</li>
</ol>
<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><h4 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h4><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次MinorGC；MinorCG垃圾收集过程中，如果Suvivor空间不足以放下Eden区中的存活对象，那么会将对象存储在老年代（分配担保机制）</p>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>HotSpot虚拟机提供了 <code>-XX:PretenureSizeThreshold</code> 参数，指定大于该设定值的对象直接在老年代分配，这样做的目的是避免在Eden区及两个Suvivor区之间来回复制，产生大量内存复制操作</p>
<h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>对象通常在Eden区诞生，如果经过第一次MinorGC后仍然存货，并且能被Suvivor容纳的话，该对象会被移动带Suvivor空间中，并且将其对象年龄设为1岁。对象在Survivor区中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 设置</p>
<h4 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h4><p>如果在Suvivor空间中低于或等于某年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的兑现就可以直接进入老年代</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在MinorGC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代的所有对象总空间，如果这个条件成立，那么这一次MinorGC可以确保是安全的。如果不成立，虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败；如果允许，那会继续检查老年代最大可用的连续空间是否大于历年晋升到老年代对象的平均大小，如果大于，将尝试进行一次MinorGC，但这次MinorGC是有风险的；如果小于，或者 <code>-XX:HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次FullGC</p>
<p>JDK6之后规则变为只要老年代的连续空间大于新生代对象总大小或者历年晋升的平均大小，就会进行MinorGC，否则将进行FullGC </p>
<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><h2 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h2><p>Class文件是一组以字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排序在文件中，中间没有任何分隔符。当遇到需要占用单个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个字节进行存储</p>
<p>Class文件采用一种类似C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”</p>
<ul>
<li>  “无符号数”属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值</li>
<li>  表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视为一张表</li>
</ul>
<p>无论是无符号数还是表，当需要描述同一类型但数量不多的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的“集合”</p>
<h4 id="魔数"><a href="#魔数" class="headerlink" title="魔数"></a>魔数</h4><p>每个Class文件的头4个字节被称为魔数，作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</p>
<p>Class文件的魔数为 0xCAFEBABE</p>
<h4 id="Class文件版本"><a href="#Class文件版本" class="headerlink" title="Class文件版本"></a>Class文件版本</h4><p>紧接着魔数的4个字节存储的是Class文件版本号：5、6字节存储的是次版本号、7、8字节存储的是主版本号。高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即时文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件</p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>紧接着主、次版本号之后的是常量池入口，常量池入口需要放置一项u2类型的数据，代表常量池容量计数值，这个容量计数值是从1开始的（也只有常量池），如常量池容量0x0016，即十进制的22，代表常量池中有21项常量，索引值范围为0~21.第0项常量空出来是为了某些指向常量池索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。</p>
</body></html>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaWeb/" rel="tag"># JavaWeb</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/11/13/Spring/" rel="prev" title="Spring">
      <i class="fa fa-chevron-left"></i> Spring
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.</span> <span class="nav-text">JVM基本介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-number">1.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">1.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%94%E8%BE%83JVM%E3%80%81JRE%E3%80%81JDK"><span class="nav-number">1.3.</span> <span class="nav-text">比较JVM、JRE、JDK</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">JVM内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-number">2.1.</span> <span class="nav-text">程序计数器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="nav-number">2.1.1.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-number">2.2.</span> <span class="nav-text">虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="nav-number">2.2.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">2.2.2.</span> <span class="nav-text">栈内存溢出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-number">2.3.</span> <span class="nav-text">本地方法栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A0%86"><span class="nav-number">2.4.</span> <span class="nav-text">堆</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="nav-number">2.4.1.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-number">2.5.</span> <span class="nav-text">方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-4"><span class="nav-number">2.5.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-number">2.5.2.</span> <span class="nav-text">方法区内存溢出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">2.6.</span> <span class="nav-text">运行时常量池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-5"><span class="nav-number">2.6.1.</span> <span class="nav-text">定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E6%B1%A0"><span class="nav-number">2.7.</span> <span class="nav-text">串池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-6"><span class="nav-number">2.7.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">2.7.2.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.7.3.</span> <span class="nav-text">位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringTable%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">2.7.4.</span> <span class="nav-text">StringTable垃圾回收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringTable%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="nav-number">2.7.5.</span> <span class="nav-text">StringTable性能调优</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-number">2.8.</span> <span class="nav-text">直接内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89-7"><span class="nav-number">2.8.1.</span> <span class="nav-text">定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%90%86"><span class="nav-number">2.8.2.</span> <span class="nav-text">原理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">3.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6"><span class="nav-number">3.1.</span> <span class="nav-text">如何判断对象可以回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-number">3.1.1.</span> <span class="nav-text">引用计数法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90"><span class="nav-number">3.1.2.</span> <span class="nav-text">可达性分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="nav-number">3.1.3.</span> <span class="nav-text">五种引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.1.</span> <span class="nav-text">标记-清除算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.2.2.</span> <span class="nav-text">标记-整理算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6"><span class="nav-number">3.2.3.</span> <span class="nav-text">标记-复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-number">3.2.4.</span> <span class="nav-text">分代垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%9B%B8%E5%85%B3VM%E5%8F%82%E6%95%B0"><span class="nav-number">3.2.4.1.</span> <span class="nav-text">相关VM参数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%8F%E5%85%B8%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-number">3.3.</span> <span class="nav-text">经典垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E8%A1%8C"><span class="nav-number">3.3.1.</span> <span class="nav-text">串行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88"><span class="nav-number">3.3.2.</span> <span class="nav-text">吞吐量优先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88"><span class="nav-number">3.3.3.</span> <span class="nav-text">响应时间优先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#G1%EF%BC%88Garbage-First%EF%BC%89"><span class="nav-number">3.3.4.</span> <span class="nav-text">G1（Garbage First）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">3.3.4.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-number">3.3.4.2.</span> <span class="nav-text">内存布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%B0%E5%BF%86%E9%9B%86"><span class="nav-number">3.3.4.3.</span> <span class="nav-text">记忆集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E9%98%B6%E6%AE%B5%E7%9A%84%E4%B8%8D%E4%B8%80%E8%87%B4%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.4.4.</span> <span class="nav-text">并发标记阶段的不一致解决方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%81%9C%E9%A1%BF%E9%A2%84%E6%B5%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="nav-number">3.3.4.5.</span> <span class="nav-text">停顿预测模型的建立</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E8%A1%8C%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.3.4.6.</span> <span class="nav-text">运行步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%8E%E5%BB%B6%E6%97%B6%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.4.</span> <span class="nav-text">低延时垃圾收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Shenandoah"><span class="nav-number">3.4.1.</span> <span class="nav-text">Shenandoah</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="nav-number">3.4.1.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9E%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="nav-number">3.4.1.2.</span> <span class="nav-text">连接矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BD%AC%E5%8F%91%E6%8C%87%E9%92%88"><span class="nav-number">3.4.1.3.</span> <span class="nav-text">转发指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B"><span class="nav-number">3.4.1.4.</span> <span class="nav-text">流程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ZGC%E6%94%B6%E9%9B%86%E5%99%A8"><span class="nav-number">3.4.2.</span> <span class="nav-text">ZGC收集器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="nav-number">3.4.2.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80-1"><span class="nav-number">3.4.2.2.</span> <span class="nav-text">内存布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E5%88%86%E9%85%8D%E9%9B%86"><span class="nav-number">3.4.2.3.</span> <span class="nav-text">重分配集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9F%93%E8%89%B2%E6%8C%87%E9%92%88"><span class="nav-number">3.4.2.4.</span> <span class="nav-text">染色指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84"><span class="nav-number">3.4.2.5.</span> <span class="nav-text">内存映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NUMA%EF%BC%88Non-Uniform-Memory-Access%EF%BC%8C%E9%9D%9E%E7%BB%9F%E4%B8%80%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E6%9E%B6%E6%9E%84%EF%BC%89"><span class="nav-number">3.4.2.6.</span> <span class="nav-text">NUMA（Non-Uniform Memory Access，非统一内存访问架构）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ZGC%E8%BF%90%E8%A1%8C%E6%AD%A5%E9%AA%A4"><span class="nav-number">3.4.2.7.</span> <span class="nav-text">ZGC运行步骤</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="nav-number">3.4.3.</span> <span class="nav-text">内存分配与回收策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8Eden%E5%88%86%E9%85%8D"><span class="nav-number">3.4.3.1.</span> <span class="nav-text">对象优先在Eden分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">3.4.3.2.</span> <span class="nav-text">大对象直接进入老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="nav-number">3.4.3.3.</span> <span class="nav-text">长期存活的对象将进入老年代</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E6%96%AD"><span class="nav-number">3.4.3.4.</span> <span class="nav-text">动态对象年龄判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D"><span class="nav-number">3.4.3.5.</span> <span class="nav-text">空间分配担保</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-number">4.</span> <span class="nav-text">类文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Class%E7%B1%BB%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.</span> <span class="nav-text">Class类文件的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AD%94%E6%95%B0"><span class="nav-number">4.1.0.1.</span> <span class="nav-text">魔数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Class%E6%96%87%E4%BB%B6%E7%89%88%E6%9C%AC"><span class="nav-number">4.1.0.2.</span> <span class="nav-text">Class文件版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-number">4.1.0.3.</span> <span class="nav-text">常量池</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MANVND</p>
  <div class="site-description" itemprop="description">There is no royal road to learning</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MANVND</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
