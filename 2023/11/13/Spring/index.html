<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Spring">
<meta property="og:url" content="http://example.com/2023/11/13/Spring/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/Users/yucan/blog/source/_posts/Spring/BeanLifeCycle-20231113095412251.png">
<meta property="og:image" content="http://example.com/Users/yucan/blog/source/_posts/Spring/AnnotationParse-20231113095412240.png">
<meta property="og:image" content="http://example.com/Users/yucan/blog/source/_posts/Spring/MVC%E6%80%9D%E6%83%B3-20231113095412257.png">
<meta property="og:image" content="http://example.com/Users/yucan/blog/source/_posts/Spring/MVC%E4%BB%8B%E7%BB%8D-20231113095412250.png">
<meta property="og:image" content="http://example.com/Users/yucan/blog/source/_posts/Spring/MVC%E7%BB%84%E4%BB%B6%E8%81%94%E7%B3%BB-20231113095412256.png">
<meta property="og:image" content="http://example.com/Users/yucan/blog/source/_posts/Spring/forward&amp;redirect-20231113095412247.png">
<meta property="og:image" content="http://example.com/Users/yucan/blog/source/_posts/Spring/forward&amp;redirect-20231113095412247.png">
<meta property="og:image" content="http://example.com/Users/yucan/blog/source/_posts/Spring/interceptor%E9%A1%BA%E5%BA%8F-20231113095412305.png">
<meta property="og:image" content="http://example.com/Users/yucan/blog/source/_posts/Spring/interceptor%E5%8E%9F%E7%90%86-20231113095412296.png">
<meta property="article:published_time" content="2023-11-13T01:51:59.000Z">
<meta property="article:modified_time" content="2023-12-04T11:24:37.320Z">
<meta property="article:author" content="MANVND">
<meta property="article:tag" content="JavaWeb">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Users/yucan/blog/source/_posts/Spring/BeanLifeCycle-20231113095412251.png">

<link rel="canonical" href="http://example.com/2023/11/13/Spring/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>Spring | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/11/13/Spring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MANVND">
      <meta itemprop="description" content="There is no royal road to learning">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Spring
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-13 09:51:59" itemprop="dateCreated datePublished" datetime="2023-11-13T09:51:59+08:00">2023-11-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-12-04 19:24:37" itemprop="dateModified" datetime="2023-12-04T19:24:37+08:00">2023-12-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <html><head></head><body><h1 id="传统JavaWeb开发困惑与解决方案"><a href="#传统JavaWeb开发困惑与解决方案" class="headerlink" title="传统JavaWeb开发困惑与解决方案"></a>传统JavaWeb开发困惑与解决方案</h1><ol>
  <li>传统JavaWeb开发耦合度太高。<br>解决思路：程序代码不自己创建对象，而是第三方创建对象 </li>
  <li>通用的事务功能耦合在业务代码中，通用的日志功能耦合在业务代码中<br>解决思路：第三方返回需要Bean对象的代理对象</li>
</ol>

<h1 id="三种思想"><a href="#三种思想" class="headerlink" title="三种思想"></a>三种思想</h1><ol>
  <li>Ioc思想：Inversion of Control，控制反转，强调的是原本在程序中创建Bean的权利反转给第三方</li>
  <li>DI思想：Dependency Injection，依赖注入，强调Bean之间的关系，这种关系第三方负责去设置</li>
  <li>AOP思想：Aspect Oriented Programming，面向切面编程，功能的横向切取，实现方式为proxy</li>
</ol>


<h1 id="Spring-Bean的配置详解"><a href="#Spring-Bean的配置详解" class="headerlink" title="Spring-Bean的配置详解"></a>Spring-Bean的配置详解</h1><p>Spring开发中主要对Bean进行配置，Bean的常用配置如下</p>
<li>id，class Bean的id和全限定名配置</li><li>name 通过name设置Bean的别名，通过别名也能直接获得Bean实例</li><li>scope Bean的作用范围，BeanFactory作为容器时取值singleton和prototype</li><li>lazy-init Bean的实例化时机，是否延迟加载。BeanFactory作为容器时无效</li><li>init-method Bean实例化后自动执行的初始化方法，method指定方法名</li><li>destroy-method Bean实例销毁前的方法，method指定方法名</li><li>autowire 设置自动注入模式，常用的有按照类型byType，按照名字byName</li><li>factory-bean factory-method 指定哪个工厂Bean的哪个方法完成Bean的创建</li><table>
  
  
  
  
  
  
  
  
</table>


<h2 id="Bean-id"><a href="#Bean-id" class="headerlink" title="Bean-id"></a>Bean-id</h2><p>不同Bean的id不能重复，不给Bean配置idBean依然有默认id。</p>
<h2 id="Bean-name"><a href="#Bean-name" class="headerlink" title="Bean-name"></a>Bean-name</h2><p>别名，Bean name可以有多个，不同name之间用逗号隔开；不指定id会用name替代id。</p>
<h2 id="Bean-scope"><a href="#Bean-scope" class="headerlink" title="Bean-scope"></a>Bean-scope</h2><p>默认情况下，Spring环境Bean的作用范围有两个：Singleton和Prototype</p>
<li>singleton: 单例，默认值，Spring容器创建的时候，就会进行Bean的实例化，并存储在容器内部的单例池中，每次getBean都是从单例池中获取相同的Bean实例</li><li>prototype: 原型，Spring容器初始化时不会创建Bean实例，当调用getBean时才会实例化Bean，每次getBean都会创建一个新的Bean实例</li><table>
  
  
</table>


<h2 id="Bean-lazy-init"><a href="#Bean-lazy-init" class="headerlink" title="Bean-lazy-init"></a>Bean-lazy-init</h2><p>当lazy-init设置为true时为延迟加载，也就是当Spring容器创建的时候，不会立刻创建Bean实例，等待用到时在创建Bean实例并存储在单例池中，后续在使用该Bean直接从单例池获取，本质上该Bean还是单例的。</p>
<h2 id="Bean的初始化和销毁方法配置"><a href="#Bean的初始化和销毁方法配置" class="headerlink" title="Bean的初始化和销毁方法配置"></a>Bean的初始化和销毁方法配置</h2><p>Bean在实例化后，可以执行指定的初始化方法完成一些初始化的操作，Bean在销毁之前也可以执行指定的销毁方法完成一些操作。</p>
<p>构造方法-&gt;初始化方法-&gt;销毁方法。</p>
<p>也可以通过实现InitializingBean接口，完成Bean的初始化操作。</p>
<h2 id="Bean的实例化设置"><a href="#Bean的实例化设置" class="headerlink" title="Bean的实例化设置"></a>Bean的实例化设置</h2><p>Spring的实例化方式主要有两种：</p>
<li>构造方式实例化：底层通过构造方法对Bean进行实例化</li><li>工厂方式实例化：底层通过调用自定义的工厂方法对Bean进行实例化</li><table>
  
  
</table>


<p>工厂方式实例化Bean分为三种：</p>
<li>静态工厂方法实例化Bean</li><li>实例工厂方法实例化Bean，先配置工厂对象，然后调用实例化的工厂对象内的方法</li><li>实现FactoryBean规范延迟实例化Bean，实现FactoryBean接口，容器自动调用实现的getObject方法</li><table>
  
  
  
</table>


<p><constructor-arg>为Bean的参数构造值</constructor-arg></p>
<h2 id="Bean的依赖注入配置"><a href="#Bean的依赖注入配置" class="headerlink" title="Bean的依赖注入配置"></a>Bean的依赖注入配置</h2><p>两种方式：</p>
<li>通过Bean的set方法注入 property</li><li>通过构造Bean的方法进行注入 constructor-arg</li><table>
  
  
</table>


<p>依赖注入的数据类型有如下三种：</p>
<li>普通数据类型，如：String、int、boolean等，通过value属性指定</li><li>引用数据类型，如：UserDaoImpl、DataSource等，通过ref属性置顶</li><li>集合数据类型，如：List、Map、Properties等，使用list使用子标签list，map使用子标签map，set使用子标签set，properties使用prop标签</li><table>
  
  
  
</table>


<h3 id="Bean自动装配"><a href="#Bean自动装配" class="headerlink" title="Bean自动装配"></a>Bean自动装配</h3><p>如果被注入的属性类型是Bean引用，name可以在Bean标签中使用autowire属性去配置自动注入方式，属性值有两个：</p>
<li>byName：通过属性名自动装配，即去匹配setXxx与id="xxx"(name="xxx")是否一致</li><li>byType：通过Bean的类型从容器中匹配，匹配出多个相同Bean类型时，报错</li><table>
  
  
</table>


<h1 id="Spring的其他配置标签"><a href="#Spring的其他配置标签" class="headerlink" title="Spring的其他配置标签"></a>Spring的其他配置标签</h1><p>Spring的xml标签大体上分为两类，一种是默认标签，一种是自定义标签</p>
<li>默认标签：不用额外导入其他命名空间约束的标签，例如Bean标签、Beans标签、import标签、alias标签</li><li>自定义标签：需要额外引入其他命名空间约束，并通过前缀引用的标签</li><table>
  
  
</table>


<h3 id="beans-profile"><a href="#beans-profile" class="headerlink" title="beans-profile"></a>beans-profile</h3><p>根据profile的值不同可以区分开发环境，使用</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.setProperty("");</span><br></pre></td></tr></tbody></table></figure>

<p>切换开发环境。</p>
<h3 id="beans-import"><a href="#beans-import" class="headerlink" title="beans-import"></a>beans-import</h3><p>导入其他配置文件，通常将一些小模块的配置文件导入到一个总的配置文件中。</p>
<h3 id="beans-alias"><a href="#beans-alias" class="headerlink" title="beans-alias"></a>beans-alias</h3><p>为Bean添加别名</p>
<h1 id="Spring的get方法"><a href="#Spring的get方法" class="headerlink" title="Spring的get方法"></a>Spring的get方法</h1><li>Object getBean(String beanName) 根据beanName从容器中获取Bean实例，要求容器中Bean唯一，返回值为Object，需要强转</li><li>T getBean(Class type) 根据Class类型从容器中获取Bean实例，要求容器中Bean类型唯一，返回值为Class类型实例，无需强转</li><li>T getBean(String beanName, Class type) 根据beanName从容器中获得Bean实例，返回值为Class类型实例，无需强转</li><table>
    
    
    
</table>


<h1 id="Spring配置非自定义Bean"><a href="#Spring配置非自定义Bean" class="headerlink" title="Spring配置非自定义Bean"></a>Spring配置非自定义Bean</h1><p>在pom导入包后，在相应的xml中配置Bean信息。</p>
<h1 id="Bean实例化的基本流程"><a href="#Bean实例化的基本流程" class="headerlink" title="Bean实例化的基本流程"></a>Bean实例化的基本流程</h1><p>Spring容器在进行初始化时，会将xml配置的bean标签的<strong>信息</strong>封装成一个BeanDefinition对象，所有的BeanDefinition对象存储在一个名为<br>beanDefinitionMap的Map集合中，Spring框架在对该Map进行遍历，使用反射创建Bean实例对象，创建好的Bean对象存储在名为singletonObjects<br>的Map集合中，当调用getBean方法时最终从该Map集合中取出Bean实例对象返回。</p>
<p>完整流程</p>
<li>加载xml配置文件，解析获取配置中的每个bean信息，封装成一个个BeanDefinition对象</li><li>将BeanDefinition存储在一个名为beanDefinitionMap的Map&lt;String, BeanDefinition&gt;中 &lt;/String&gt;</li><li>ApplicationContext底层遍历beanDefinitionMap，创建Bean实例对象</li><li>创建好的Bean实例对象，存储在一个名为singletonObjects的Map&lt;String, Object&gt;中</li><li>当执行applicationContext.getBean(beanName)时，从singletonObject去匹配Bean实例返回</li><table>
    
    
    
    
    
</table>


<h1 id="Spring后处理器"><a href="#Spring后处理器" class="headerlink" title="Spring后处理器"></a>Spring后处理器</h1><p>Spring的后处理器时Spring对外开发的重要拓展点，允许介入到Bean的整个实例化流程，以达到动态注册BeanDefinition，动态修改BeanDefinition，<br>以及动态修改Bean的作用。Spring主要有两种后处理器：</p>
<li>BeanFactoryPostProcessor: Bean工厂后处理器，在BeanDefinitionMap填充完毕，Bean实例化之前执行</li><li>BeanPostProcessor: Bean后处理器，一般在Bean实例化之后，填充到单例池singletonObjects之前执行</li><table>
    
    
</table>


<h2 id="Bean工厂后处理器-BeanFactoryPostProcessor"><a href="#Bean工厂后处理器-BeanFactoryPostProcessor" class="headerlink" title="Bean工厂后处理器-BeanFactoryPostProcessor"></a>Bean工厂后处理器-BeanFactoryPostProcessor</h2><p>BeanFactoryPostProcessor是一个接口规范，实现了该接口的类只要交由Spring容器管理，Spring就会回调该接口的方法，用于<br>对BeanDefinition注册和修改。</p>
<p>BeanFactoryPostProcessor定义如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BeanFactoryPostProcessor</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>Spring提供一个BeanFactoryPostProcessor的子接口BeanDefinitionRegistryPostProcessor专门用于注册<br>BeanDefinition操作</p>
<h2 id="Bean后处理器-BeanPostProcessor"><a href="#Bean后处理器-BeanPostProcessor" class="headerlink" title="Bean后处理器-BeanPostProcessor"></a>Bean后处理器-BeanPostProcessor</h2><p>Bean被实例化后，到最终缓存到名为singletonObjects单例池之前，中间会经过Bean的初始化过程，称为Bean后处理。<br>跟Bean工厂后处理类似，它也是一个接口，实现了该接口并被容器管理的BeanPostProcessor，会在流程节点上被Spring自动调用</p>
<h1 id="Spring-Bean的生命周期"><a href="#Spring-Bean的生命周期" class="headerlink" title="Spring Bean的生命周期"></a>Spring Bean的生命周期</h1><p>Spring Bean的生命周期是从Bean实例化之后，即通过反射创建出对象之后，到Bean成为一个完整对象，最终存储到单例池中，<br>这个过程被称作Spring Bean的生命周期。Spring Bean的生命周期大体上分为三个阶段：</p>
<li>Bean的实例化阶段：Spring框架会取出BeanDefinition的信息进行判断当前Bean的范围是否是singleton，是否是
不延迟加载的，是否是FactoryBean等，最终将一个普通的singleton的Bean通过反射进行实例化。</li><li>Bean的初始化阶段：Bean创建之后还仅仅是“半成品”，还需要对Bean实例的属性进行填充、执行一些Aware接口方法、
执行BeanPostProcessor方法、执行InitializingBean接口的初始化方法、执行自定义初始化init方法等。</li><li>Bean的完成阶段：经过初始化阶段后，Bean就成为了一个完整的Bean，被存储在单例池singletonObjects中去，即完成了
Spring Bean的整个生命周期。</li><table>
    
    
    
</table>


<p>Spring Bean的初始化过程涉及如下几个过程：</p>
<li>Bean实例的属性填充</li><li>Aware接口属性注入</li><li>BeanPostProcessor的before()方法回调</li><li>InitializingBean接口的初始化方法回调</li><li>自定义初始化方法init回调</li><li>BeanPostProcessor的after()方法回调</li><table>
    
    
    
    
    
    
</table>


<p>BeanDefinition中有对当前Bean实体的诸如信息通过属性propertyValues进行了存储。</p>
<p>Spring在进行属性注入时，分为以下三种情况：</p>
<li>注入普通属性，String、int或存储基本类型的集合时，直接通过set方法的反射设置进去</li><li>注入单向对象引用属性时，从容器中getBean获取后通过set方法反射设置进去，如果容器中没有，则先创建被注入对象
Bean实例后，再进行诸如操作</li><li>注入双向对象引用属性，涉及循环引用</li><table>
    
    
    
</table>


<p>Bean实例属性填充<br>Spring提供了<strong>三级缓存</strong>存储完整Bean实例和半成品Bean实例，用于解决循环引用问题<br>在DefaultListableBeanFactory的上四级父类DefaultSingletonBeanRegistry中提供如下三个Map：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultSingletonBeanRegistry</span> {</span><br><span class="line">    <span class="comment">// 1、最终存储单例Bean成品的容器，即实例化和初始化都完成的Bean，称为“一级缓存”</span></span><br><span class="line">    Map&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">256</span>);</span><br><span class="line">    <span class="comment">// 2、早期Bean单例池，缓存半成品对象，且当前对象已经被其他对象引用，称为“二级缓存”</span></span><br><span class="line">    Map&lt;String, Object&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 3、单例Bean的工厂池，缓存半成品对象，对象未被引用，使用时再通过工厂创建Bean，称之为“三级缓存”</span></span><br><span class="line">    Map&lt;String, ObjectFactory&lt;?&gt;&gt; earlySingletonObjects = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>(<span class="number">16</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>A和B循环依赖过程结合三级缓存：</p>
<li>A实例化对象，但尚未初始化，将A存储在三级缓存</li><li>A属性注入，需要B，从缓存中获取，没有B</li><li>B实例化对象，但尚未初始化，将B存储在三级缓存</li><li>B属性依赖注入，需要A，从三级缓存获取A，A从三级缓存移入二级缓存</li><li>B执行其他生命周期过程，最终成为一个完整Bean，存储到一级缓存，删除二三级缓存</li><li>A注入B</li><li>A执行其他生命周期过程，最终成为一个完整Bean，存储到一级缓存，删除二三级缓存</li><table>
    
    
    
    
    
    
    
</table>


<p>常用的Aware接口</p>
<p>Aware接口是一种框架辅助属性注入的一种思想，Aware可以注入一些底层对象</p>
<li>接口：ServletContextAware 回调方法：setServletContext(ServletContext context) Spring框架回调方法注入ServletContext对象，web环境下生效</li><li>接口：BeanFactoryAware 回调方法：setBeanFactory(BeanFactory factory) Spring框架回调方法注入beanFactory对象</li><li>接口：BeanNameAware 回调方法：setBeanName(String beanName) Spring框架回调方法注入当前Bean在容器中的beanName</li><li>接口：ApplicationContextAware 回调方法：setApplicationContext(ApplicationContext application) Spring框架回调方法注入applicationContext对象</li><table>
    
    
    
    
</table>


<p><img src="/Users/yucan/blog/source/_posts/Spring/BeanLifeCycle-20231113095412251.png" alt="Bean生命周期" title="Bean生命周期"></p>
<h1 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h1><p>整合包里提供了一个SqlSessionFactoryBean和一个扫描Mapper的配置对象，SqlSessionFactoryBean一旦被实例化，<br>就开始扫描Mapper并通过动态代理产生Mapper的实现类存储到Spring容器中。相关的有如下四个类：</p>
<li>SqlSessionFactoryBean：需要进行配置，用于提供SqlSessionFactory</li><li>MapperScannerConfigure：需要进行配置，用于扫描指定mapper注册BeanDefinition</li><li>MapperFactoryBean：Mapper的FactoryBean，获得指定Mapper时调用getObject方法</li><li>ClassPathMapperScanner：definition.setAutowireMode(2)修改了自动注入状态，所以MapperFactoryBean中的setSqlSessionFactory会自动注入进去</li><table>
    
    
    
    
</table>


<h1 id="Spring整合第三方框架"><a href="#Spring整合第三方框架" class="headerlink" title="Spring整合第三方框架"></a>Spring整合第三方框架</h1><li>将自定义标签的约束与物理约束文件与网络约束名称的约束以键值对形式存储到一个spring.schemas文件里，该文件存储在类加载路径的META-INF里，Spring会自动加载</li><li>将自定义命名空间的名称与自定义命名空间的处理器映射关系以键值对形式存在一个叫spring.handlers文件里，该文件存储在类加载路径的META-INF里，Spirng会自动加载</li><li>准备好NamespaceHandler，如果命名空间里只有一个标签，那么直接在parse方法中进行解析即可，一般解析结果就是注册该标签对应的BeanDefinition。如果命名空间里有多个标签，那么可以在init方法中为每个标签都注册一个BeanDefinitionParser，在执行NamespaceHandler的parse方法时再分流给不同的BeanDefinitionParser进行解析（重写doParse方法）</li><table>
    
    
    
</table>


<li>确定命名空间名称、schema虚拟路径、标签名称</li><li>编写schema约束文件***.xsd</li><li>在类加载路径下创建META-INF目录，编写约束映射文件spring.schemas和处理器映射文件spring.handlers</li><li>编写命名空间处理器，在init方法注册Parser</li><li>编写标签的解析器</li><li>在applicationContext.xml配置文件中引入命名空间</li><li>在applicationContext.xml配置文件中使用自定义的标签</li><table>
    
    
    
    
    
    
    
</table>

<h1 id="基于注解的Spring开发"><a href="#基于注解的Spring开发" class="headerlink" title="基于注解的Spring开发"></a>基于注解的Spring开发</h1><h2 id="Bean基本注解开发"><a href="#Bean基本注解开发" class="headerlink" title="Bean基本注解开发"></a>Bean基本注解开发</h2><p>基于Bean注解，主要使用注解的方式提到原有xml的<bean>标签及其标签属性的配置</bean></p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span> <span class="attr">scope</span>=<span class="string">""</span> <span class="attr">lazy-init</span>=<span class="string">""</span> <span class="attr">init-method</span>=<span class="string">""</span> <span class="attr">destroy-method</span>=<span class="string">""</span> <span class="attr">abstract</span>=<span class="string">""</span> <span class="attr">autowire</span>=<span class="string">""</span> <span class="attr">factory-bean</span>=<span class="string">""</span> <span class="attr">factory-method</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>使用@Component注解替代<bean>标签</bean></p>
<table>
<thead>
<tr>
<th>xml配置</th>
<th align="left">注解</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><bean id="" class=""></bean></td>
<td align="left">@Component</td>
<td>被该注解标识的类，会在指定扫描范围内被Spring加载并实例化</td>
</tr>
<tr>
<td><bean scope=""></bean></td>
<td align="left">@Scope</td>
<td>在类上或使用了@Bean注解的方法上，标注Bean的作用范围，取值为singleton或prototype</td>
</tr>
<tr>
<td><bean lazy-init=""></bean></td>
<td align="left">@Lazy</td>
<td>在类上或使用了@Bean注解的方法上，标注Bean是否延迟加载，取值为true和false</td>
</tr>
<tr>
<td><bean init-method=""></bean></td>
<td align="left">@PostConstruct</td>
<td>在方法上使用，标注Bean的实例化后执行的方法</td>
</tr>
<tr>
<td><bean destroy-method=""></bean></td>
<td align="left">@PreDestroy</td>
<td>在方法上使用，标注Bean的销毁前执行方法</td>
</tr>
</tbody></table>
<p>由于JavaEE开发时分层的，为了每层Bean标识的注解语义化更加明确，@Component又衍生出了如下三个注解：</p>
<table>
<thead>
<tr>
<th>@Component衍生注解</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@Repository</td>
<td>在Dao层类上使用</td>
</tr>
<tr>
<td>@Servcie</td>
<td>在Service层类上使用</td>
</tr>
<tr>
<td>@Controller</td>
<td>在Web层类上使用</td>
</tr>
</tbody></table>
<h2 id="Bean依赖注入注解开发"><a href="#Bean依赖注入注解开发" class="headerlink" title="Bean依赖注入注解开发"></a>Bean依赖注入注解开发</h2><p>Bean依赖注入的注解，主要使用注解的方式替代xml的<property>标签完成属性的注入操作。</property></p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">ref</span>=<span class="string">""</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>Spring主要提供如下注解，用于在Bean内部进行属性注入：</p>
<table>
<thead>
<tr>
<th>属性注入注解</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>@Value</td>
<td>使用在字段或方法上，用于注入普通数据</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段或方法上，用于根据类型(byType)注入引用数据</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>使用在字段或方法上，结合@Autowired，根据名称注入，只在方法上使用不用结合@Autowired</td>
</tr>
<tr>
<td>@Resource</td>
<td>使用在字段或方法上，根据类型或名称进行注入</td>
</tr>
</tbody></table>
<p>以上注解也可以卸载setter方法上。</p>
<p>@Autowired 如果同一类型的Bean有多个，尝试根据名字进行二次匹配，匹配不成功再报错。</p>
<h2 id="非自定义Bean注解开发"><a href="#非自定义Bean注解开发" class="headerlink" title="非自定义Bean注解开发"></a>非自定义Bean注解开发</h2><p>非自定义Bean不能像自定义Bean一样使用Component进行管理，非自定义Bean要通过工厂的方式进行实例化，使用@Bean标注方法即可，@Bean的属性为beanName，如不指定则为当前工厂方法名称。</p>
<p>@Bean注解下的方法内的依赖会自动根据类型注入</p>
<p>如果@Bean工厂方法需要<strong>参数</strong>的话，有如下几种注入方式</p>
<li>使用@Autowired根据类型自动进行Bean的匹配，@Autowired可以省略</li><li>使用@Qualifier根据名称进行Bean的匹配</li><li>使用@Value根据名称进行普通数据类型匹配</li><table>
    
    
    
</table>

<h2 id="Bean配置类的注解开发"><a href="#Bean配置类的注解开发" class="headerlink" title="Bean配置类的注解开发"></a>Bean配置类的注解开发</h2><p>@Component等注解替代<bean>标签，定义一个配置类替代原有的xml配置文件，<bean>标签以外的标签，一般都是再配置类上使用注解完成。</bean></bean></p>
<p>@Configuration注解标识的类为配置类，替代原有xml配置文件，该注解第一个作用时标识该类是一个配置类，第二个作用是具备@Component作用</p>
<p>@ComponentScan组件扫描配置，替代原有xml文件中的&lt;context:component-scan base-package=””/&gt;</p>
<p>base-package的配置方法：</p>
<li>指定一个或多个包名：扫描指定包及其子包下使用注解的类</li><li>不配置包名：扫描当前@ComponentScan注解配置类所在包及其子包下的类</li><table>
    
    
</table>


<p>@PropertySource注解用于加载外部properties资源配置，替代原有xml中的&lt;context:property-placeholder location=””/&gt;配置</p>
<p>@Import用于加载其他配置类，替代原有xml中的&lt;import resource=”classpath:beans.xml”/&gt;配置</p>
<p>扩展：@Primary注解用于标注相同类型的Bean优先被使用权，@Primary与@Component和@Bean一起使用，标注该Bean的优先级更高，通过类型获取Bean或通过@Autowired根据类型进行注入时，会优先选择优先级更高的</p>
<p>扩展：@profile注解作痛同于xml配置里的profile属性，是进行环境切换使用的。</p>
<p>注册@Profile标注再类或方法上，标注当前产生的Bean从属于哪个环境，只有激活了当前环境，被标注的Bean才能被注册到Spring容器里，不指定环境的Bean，任何环境下都能注册到Spring容器里。</p>
<p>可以使用两种方式指定被激活的环境：</p>
<li>使用命令行动态参数，虚拟机参数位置加载-Dspring.profiles.active=test</li><li>使用代码的方式设置环境变量System.setProperty("spring.profiles.active", "test");</li><table>
    
    
</table>


<h2 id="Spring注解的解析原理"><a href="#Spring注解的解析原理" class="headerlink" title="Spring注解的解析原理"></a>Spring注解的解析原理</h2><p>使用@Component等注解配置完毕后，要配置组件扫描才能使注解生效；</p>
<p>xml配置组件扫描：</p>
<figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.itheima"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>配置类配置组件扫描：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan("com.itheima")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> {</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/Users/yucan/blog/source/_posts/Spring/AnnotationParse-20231113095412240.png" title="AnnotationParse"></p>
<h2 id="Spring注解方式整合第三方框架"><a href="#Spring注解方式整合第三方框架" class="headerlink" title="Spring注解方式整合第三方框架"></a>Spring注解方式整合第三方框架</h2><p>@Import可以导入以下三种类：</p>
<li>普通的配置类</li><li>实现ImportSelector接口的类</li><li>实现ImportBeanDefinitionRegistrar接口的类</li><table>
    
    
    
</table>

<h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1><h2 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h2><p>AOP，Aspect Oriented Programming，面向切面编程，是面向对象编程OOP的升华。OOP是纵向对一个事物的抽象，一个对象包括静态的属性信息，包括动态的方法信息等。而AOP是横向的对不同事物的抽象，属性与属性、方法与方法、对象与对象都可以组成一个切面，而用这种思维去设计编程的方式叫做面向切面编程。</p>
<h2 id="AOP思想的实现方案"><a href="#AOP思想的实现方案" class="headerlink" title="AOP思想的实现方案"></a>AOP思想的实现方案</h2><p>动态代理技术，运行期间，对目标对象的方法进行增强，代理对象同名方法内可以执行原有逻辑的同时嵌入执行其他增强逻辑或其他对象的方法。</p>
<h2 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h2><table>
<thead>
<tr>
<th>概念</th>
<th>单词</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>目标对象</td>
<td>Target</td>
<td>被增强的方法所在的对象</td>
</tr>
<tr>
<td>代理对象</td>
<td>Proxy</td>
<td>对目标对象进行增强后的对象，客户端实际调用的对象</td>
</tr>
<tr>
<td>连接点</td>
<td>Joinpoint</td>
<td>目标对象中可以被增强的方法</td>
</tr>
<tr>
<td>切入点</td>
<td>Pointcut</td>
<td>目标对象中实际被增强的方法</td>
</tr>
<tr>
<td>通知\增强</td>
<td>Advice</td>
<td>增强部分的代码逻辑</td>
</tr>
<tr>
<td>切面</td>
<td>Aspect</td>
<td>增强和切入点的组合</td>
</tr>
<tr>
<td>织入</td>
<td>Weaving</td>
<td>将通知和切入点组合动态组合的过程</td>
</tr>
</tbody></table>
<h2 id="基于xml配置AOP"><a href="#基于xml配置AOP" class="headerlink" title="基于xml配置AOP"></a>基于xml配置AOP</h2><li>导入AOP相关坐标</li><li>准备目标类、增强类，并配置给Spring管理</li><li>配置切点表达式（哪些方法被增强）</li><li>配置织入（切点被哪些通知方法增强，是前置增强还是后置增强）</li><table>
    
    
    
    
</table>


<p>切点表达式是配置要对哪些连接点进行通知的增强，语法如下：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution ([访问修饰符]返回值类型 包名.类名.方法名(参数))</span><br></pre></td></tr></tbody></table></figure>

<p>其中，</p>
<li>访问修饰符可以省略不写</li><li>返回值类型、某一级包名、类名、方法名可以使用*表示任意</li><li>包名与类名之间使用单点表示该包下的类，使用双点表示该包及其子包下的类</li><li>参数列表可以使用两个点表示任意参数</li><table>
    
    
    
    
</table>


<p>AspectJ的通知有五种类型：</p>
<table>
<thead>
<tr>
<th>通知名称</th>
<th>配置方式</th>
<th>执行时机</th>
</tr>
</thead>
<tbody><tr>
<td>前置通知</td>
<td>&lt;aop:before&gt;</td>
<td>目标方法执行之前执行</td>
</tr>
<tr>
<td>后置通知</td>
<td>&lt;aop:after-returning&gt;</td>
<td>目标方法执行之后执行，目标方法异常时，不在执行</td>
</tr>
<tr>
<td>环绕通知</td>
<td>&lt;aop:around&gt;</td>
<td>目标方法执行前后执行，目标方法异常时，环绕后方法不再执行</td>
</tr>
<tr>
<td>异常通知</td>
<td>&lt;aop:after-throwing&gt;</td>
<td>目标方法抛出异常时执行</td>
</tr>
<tr>
<td>最终通知</td>
<td>&lt;aop:after&gt;</td>
<td>不管目标方法是否有异常，最终都会执行</td>
</tr>
</tbody></table>
<p>通知方法被调用时，Spring可以为其传递一些必要的参数</p>
<table>
<thead>
<tr>
<th>参数类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>JoingPoint</td>
<td>连接点对象，任何通知都可使用，可以获得当前目标对象、目标方法参数等信息</td>
</tr>
<tr>
<td>ProceedingJoinPoint</td>
<td>JoinPoint子类对象，主要是在环绕通知中执行proceed()，进而执行目标方法</td>
</tr>
<tr>
<td>Throwable</td>
<td>异常对象，使用在异常通知中，需要在配置文件中指出异常对象名称</td>
</tr>
</tbody></table>
<p>AOP配置的&lt;aop:aspect&gt;与&lt;aop:advisor&gt;</p>
<p>语法形式不同：</p>
<li>advisor是通过实现接口来确认通知的类型</li><li>aspect是通过配置确认通知的类型，更加灵活</li><table>
    
    
</table>


<p>可配置的切面数量不同：</p>
<li>一个advisor只能配置一个固定通知和一个切点表达式</li><li>一个aspect可以配置多个通知和多个切点表达式任意组合</li><table>
    
    
</table>


<p>使用场景不同：</p>
<li>允许随意搭配情况下可以使用aspect进行配置</li><li>如果通知类型单一、切面单一的情况下可以使用advisor进行配置</li><li>在通知类型已经固定，不用认为指定通知类型时，可以使用advisor进行配置</li><table>
    
    
    
</table>

<p>&lt;tx:method name=””, isolation=””, timeout=””, read-only=”” propagation=””&gt;</p>
<p>name用来指定方法，*代表通配符；</p>
<p>isolation指定事务的隔离级别，并发事务存在三大问题：脏读、不可重复读、幻读。</p>
<table>
<thead>
<tr>
<th>isolation属性</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>DEFAULT</td>
<td>默认隔离级别，取决于当前数据库隔离级别</td>
</tr>
<tr>
<td>READ_UNCOMMITTED</td>
<td>A事务可以读取B事务尚未提交的事务记录，不能解决任何并发问题，安全性最低，性能最高</td>
</tr>
<tr>
<td>READ_COMMITTED</td>
<td>A事务只能读取到其他事务已经提交的记录，不能读取到未提交的记录。可以解决脏读问题，但是不能解决不可重复读和幻读</td>
</tr>
<tr>
<td>REPEATABLE_READ</td>
<td>A事务多次从数据库读取某条记录结果一致，可以解决不可重复读，不可以解决幻读</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>串行化，可以解决任何并发问题，安全性最高，但是性能最低</td>
</tr>
</tbody></table>
<p>timeout：超时时间，默认-1，单位为秒</p>
<p>read-only：是否只读</p>
<p>propagation：事务的传播行为，解决业务方法调用业务方法（事务嵌套问题），设置事务的传播行为，主要解决A方法调用B方法时，事务的传播方式问题。</p>
<table>
<thead>
<tr>
<th>事务传播行为</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>REQUIRED（默认值）</td>
<td>A调用B，B需要事务，如果A有事务B就加入A的事务中，如果A没有事务，B就自己创建一个事务</td>
</tr>
<tr>
<td>REQUIRED_NEW</td>
<td>A调用B，B需要新事务，如果A有事务就挂起，B自己创建一个新的事务</td>
</tr>
<tr>
<td>SUPPORTS</td>
<td>A调用B，B有无事务无所谓，A有事务就加入到A事务中，A无事务B就以非事务方式运行</td>
</tr>
<tr>
<td>NOT_SUPPORTS</td>
<td>A调用B，B以无事务方式执行，A如果有事务则挂起</td>
</tr>
<tr>
<td>NEVER</td>
<td>A调用B，B以无事务方式执行，A如果有事务则抛出异常</td>
</tr>
<tr>
<td>MANDATORY</td>
<td>A调用B，B要加入A的事务中，如果A无事务则抛出异常</td>
</tr>
<tr>
<td>NESTED</td>
<td>A调用B，B创建一个新事务，A有事务就作为嵌套事务存在，A没有事务就以创建的新事务执行</td>
</tr>
</tbody></table>
<h1 id="Spring整合web环境"><a href="#Spring整合web环境" class="headerlink" title="Spring整合web环境"></a>Spring整合web环境</h1><h2 id="Javaweb三大组件及环境问题"><a href="#Javaweb三大组件及环境问题" class="headerlink" title="Javaweb三大组件及环境问题"></a>Javaweb三大组件及环境问题</h2><p>在Java语言范畴内，web层框架都是基于Javaweb基础组件完成的，有如下</p>
<table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>Servlet</td>
<td>服务器端小程序，负责接收客户端请求并做出响应</td>
<td>单例对象，默认第一次访问创建，可以通过配置指定服务器启动就创建，Servlet创建完毕会执行初始化init方法。每个Servlet有一个service方法，每次访问都会执行service方法，但是缺点时一个业务功能就需要配置一个Servlet</td>
</tr>
<tr>
<td>Filter</td>
<td>过滤器，负责对客户端请求进行过滤操作</td>
<td>单例对象，服务器启动时创建，对象创建完毕执行init方法，对客户端的请求进行过滤，符合要求的放行，不符合要求的直接响应客户端，执行过滤的核心方法doFilter</td>
</tr>
<tr>
<td>Listener</td>
<td>监听器，负责对域对象的创建和属性变化进行监听</td>
<td>根据类型和作用不同，可分为监听域对象创建销毁和域对象属性内容变化，根据监听的域不同，又可分为监听Request域，监听Session域，监听ServletContext域</td>
</tr>
</tbody></table>
<h2 id="Spring整合web环境的思路及实现"><a href="#Spring整合web环境的思路及实现" class="headerlink" title="Spring整合web环境的思路及实现"></a>Spring整合web环境的思路及实现</h2><p>在进行java开发时要遵循三重架构+MVC，Spring操作最核心的就是Spring容器，web层需要注入Service，service层需要注入Dao(Mapper)，web层使用Servlet技术充当，需要在Servlet中获得Spring容器。web层代码如果都去编写创建AnnotationConfigApplicationContext代码，那么配置类重复被加载了，Spring容器也重复被创建了，不能每次想从容器中获得一个Bean都得先创建一次容器。</p>
<li>ApplicationContext创建一次，配置类加载一次</li><li>web服务器启动时，执行第一步操作，后续直接从容器中获取Bean使用</li><li>ApplicationContext的引用在web层任何位置都可以获取</li><table>
    
    
    
</table>


<p>解决方法：</p>
<li>在ServletContextListener的contextInitialized方法中执行ApplicationContext的创建。或在Servlet的init方法中执行ApplicationContext的创建，并给Servlet的load-on-startup属性一个数字值，确保服务器启动Servlet就创建</li><li>将创建好的ApplicationContext存储到ServletContext域中，这样整个web层任何位置都可以获取到</li><table>
    
    
</table>

<h2 id="MVC框架思想及其设计思路"><a href="#MVC框架思想及其设计思路" class="headerlink" title="MVC框架思想及其设计思路"></a>MVC框架思想及其设计思路</h2><p><img src="/Users/yucan/blog/source/_posts/Spring/MVC%E6%80%9D%E6%83%B3-20231113095412257.png"></p>
<h1 id="SpringMVC简介"><a href="#SpringMVC简介" class="headerlink" title="SpringMVC简介"></a>SpringMVC简介</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>SpringMVC是一个基于Spring开发的MVC轻量级框架，Spring3.0后发布的组件，SpringMVC和Spring可以无缝整合，使用DispatcherServlet作为前端控制器，且内部提供了处理器映射器、处理器适配器、视图解析器等组件，可以简化JavaBean封装，Json转换、文件上传等操作。</p>
<p><img src="/Users/yucan/blog/source/_posts/Spring/MVC%E4%BB%8B%E7%BB%8D-20231113095412250.png"></p>
<h2 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h2><p>web.xml</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--  配置ContextLoaderListener--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  配置DispatcherServlet--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>spring-mvc.xml 集成Controller与Servlet</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.itheima.controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>applicationContext.xml 集成Spring容器与MVC</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.itheima.service"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="SpringMVC关键组件"><a href="#SpringMVC关键组件" class="headerlink" title="SpringMVC关键组件"></a>SpringMVC关键组件</h2><table>
<thead>
<tr>
<th>组件</th>
<th>描述</th>
<th>常用组件</th>
</tr>
</thead>
<tbody><tr>
<td>处理器映射器：HandlerMapping</td>
<td>匹配映射路径对应的Handler，返回可执行的处理器链对象HandlerExecutionChain对象</td>
<td>RequestMappingHandlerMapping</td>
</tr>
<tr>
<td>处理器适配器：HandlerAdapter</td>
<td>匹配HandlerExecutionChain对应的适配器进行处理器调用，返回视图模型对象</td>
<td>RequestMappingHandlerAdapter</td>
</tr>
<tr>
<td>视图解析器：ViewResolver</td>
<td>对视图模型对象进行解析</td>
<td>InternalResourceViewResolver</td>
</tr>
</tbody></table>
<p>三个重要组件的关系如下：</p>
<p><img src="/Users/yucan/blog/source/_posts/Spring/MVC%E7%BB%84%E4%BB%B6%E8%81%94%E7%B3%BB-20231113095412256.png"></p>
<p>SpringMVC的默认组件，SpringMVC在前端控制器DispatchServlet加载时，就会进行初始化操作，在进行初始化时，就会加载SpringMVC默认指定的一些组件，这些默认组件配置在DispatcherServlet.properties文件中，该文件存在于spring-webmvc-*.jar包下的org\springframework\web\servlet\DispatcherServlet.properties下。</p>
<p><strong>DispatcherServlet默认会生成三个HandlerMapping，但如果在Spring容器中手动创建那么DispatcherServlet不会默认生成HandlerMapping，使用容器中创建的HandlerMapping。</strong></p>
<h2 id="SpringMVC的请求处理"><a href="#SpringMVC的请求处理" class="headerlink" title="SpringMVC的请求处理"></a>SpringMVC的请求处理</h2><h3 id="请求映射路径的配置"><a href="#请求映射路径的配置" class="headerlink" title="请求映射路径的配置"></a>请求映射路径的配置</h3><p>配置映射路径，映射器处理器才能找到Controller的方法资源，目前主流映射路径配置方式是@RequestMapping</p>
<table>
<thead>
<tr>
<th>相关注解</th>
<th>作用</th>
<th>使用位置</th>
</tr>
</thead>
<tbody><tr>
<td>@RequestMapping</td>
<td>设置控制器方法的访问资源路径，可以接收任何请求</td>
<td>方法和类上</td>
</tr>
<tr>
<td>@GetMapping</td>
<td>设置控制器方法的访问资源路径，可以接收GET请求</td>
<td>方法和类上</td>
</tr>
<tr>
<td>@PostMapping</td>
<td>设置控制器方法的访问资源路径，可以接收POST请求</td>
<td>方法和类上</td>
</tr>
</tbody></table>
<p>@RequestParam(value, required defaultValue)</p>
<p>为http的get请求的参数提供映射，value表示http请求的参数名，required表示是否必要，默认false，defaultValue表示默认值。</p>
<h3 id="请求数据的接收"><a href="#请求数据的接收" class="headerlink" title="请求数据的接收"></a>请求数据的接收</h3><p>接收实体JavaBean的属性数据，单个JavaBean数据：提交的参数名称只要与Java的属性名一致，就可以进行自动封装。</p>
<h4 id="接收JSON请求体"><a href="#接收JSON请求体" class="headerlink" title="接收JSON请求体"></a>接收JSON请求体</h4><li>@RequestBody 把请求体的数据封装到指定字符串。然后使用JSON解析</li><li>配置RequestMappingHandlerAdapter.messageConverters，实现自动解析</li><table>
    
    
</table>


<h4 id="接收Restful风格数据"><a href="#接收Restful风格数据" class="headerlink" title="接收Restful风格数据"></a>接收Restful风格数据</h4><p>Rest(Representational State Transfer)表象化状态转变，基于HTTP、URI、xml、JSON等标准和协议，支持轻量级、跨平台、跨语言的架构设计。</p>
<p>Restful风格的请求，常见的规则有三点：</p>
<p>1、用URI表示某个模块资源，资源名称为名词</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>URI资源</th>
</tr>
</thead>
<tbody><tr>
<td>用户模块user</td>
<td><a target="_blank" rel="noopener" href="http://localhost/user">http://localhost/user</a></td>
</tr>
<tr>
<td>商品模块product</td>
<td><a target="_blank" rel="noopener" href="http://localhsot/product">http://localhsot/product</a></td>
</tr>
<tr>
<td>账户模块account</td>
<td><a target="_blank" rel="noopener" href="http://localhost/account">http://localhost/account</a></td>
</tr>
<tr>
<td>日志模块log</td>
<td><a target="_blank" rel="noopener" href="http://localhost/log">http://localhost/log</a></td>
</tr>
</tbody></table>
<p>2、用请求方式表示模块具体业务动作，GET表示查询、POST表示插入、PUT表示更新、DELETE表示删除</p>
<table>
<thead>
<tr>
<th>URI资源</th>
<th>请求方式</th>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://localhost/user/100">http://localhost/user/100</a></td>
<td>GET</td>
<td>存在URL地址中：100</td>
<td>查询id=100的User数据</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://localhost/user">http://localhost/user</a></td>
<td>POST</td>
<td>存在请求体JSON中：{“username”: “haohao”, “age”: 18}</td>
<td>插入User数据</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://localhost/user">http://localhost/user</a></td>
<td>PUT</td>
<td>存在请求体JSON中：{“id”: 100, “username”: “haohao”, “age”: 18}</td>
<td>修改id=100的User数据</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://localhost/user/100">http://localhost/user/100</a></td>
<td>DELETE</td>
<td>存在URL地址中：100</td>
<td>删除id=100的User数据</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://localhost/product/5">http://localhost/product/5</a></td>
<td>GET</td>
<td>存在URL地址中：5</td>
<td>查询id=5的Product数据</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://localhost/product">http://localhost/product</a></td>
<td>POST</td>
<td>存在请求体JSON中：{“proName”: “小米手机”, “price”: 1299}</td>
<td>插入Product数据</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://localhost/product">http://localhost/product</a></td>
<td>PUT</td>
<td>存在请求体JSON中：{“id”: 5, “proName”: “小米手机”, “price”: 1299}</td>
<td>修改id=5的Product数据</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://localhost/product/5">http://localhost/product/5</a></td>
<td>DELETE</td>
<td>存在URL地址中：5</td>
<td>删除id=5的Product数据</td>
</tr>
</tbody></table>
<p>3、用HTTP状态响应状态码表示结果，国内常用的响应包括三部分：状态码、状态信息、响应数据</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"code"</span><span class="punctuation">:</span> <span class="number">200</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"message"</span><span class="punctuation">:</span> <span class="string">"成功"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"data"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"username"</span><span class="punctuation">:</span> <span class="string">"haohao"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"age"</span><span class="punctuation">:</span> <span class="number">18</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"code"</span><span class="punctuation">:</span> <span class="number">300</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"message"</span><span class="punctuation">:</span> <span class="string">"执行错误"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"data"</span><span class="punctuation">:</span> <span class="string">""</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>

<p>@PathVariable(“”) 将路径变量赋值。</p>
<h4 id="接收文件"><a href="#接收文件" class="headerlink" title="接收文件"></a>接收文件</h4><p>接收文件上传的数据，文件上传的表单有一定的要求。</p>
<li>表单的提交方式必须是POST</li><li>表单的enctype属性必须是multipart/form-data</li><li>文件上传项需要有name属性</li><table>
    
    
    
</table>


<p>服务器段，由于映射器适配器需要文件上传解析器，而该解析器默认未被注册，所以手动注册。</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--    配置文件上传解析器，id的名字是固定写法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.support.StandardServletMultipartResolver"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>而CommonsMultipartResolver底层使用的Apache的是Common-fileupload等工具API进行文件上传</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>web.xml中配置上传文件的限制及安放目录等</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">multipart-config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      临时文件的目录--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">location</span>&gt;</span>C:/Users/manvnd/Desktop<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      上传文件最大2M--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">max-file-size</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">max-file-size</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--      上传文件整个请求不超过4M--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">max-request-size</span>&gt;</span>4194304<span class="tag">&lt;/<span class="name">max-request-size</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">multipart-config</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>http请求测试</p>
<figure class="highlight http"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST http://localhost:8080/param10</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>multipart/form-data; boundary=WebAppBoundary</span><br><span class="line"></span><br><span class="line">--WebAppBoundary</span><br><span class="line"><span class="attribute">Content-Disposition</span><span class="punctuation">: </span>form-data; name="myFile"; filename="test.txt"</span><br><span class="line"></span><br><span class="line">&lt; ./src/main/resources/test.txt</span><br><span class="line">--WebAppBoundary--</span><br></pre></td></tr></tbody></table></figure>

<p>获得客户端携带的Cookie数据</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping("/cookies")</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">cookies</span><span class="params">(<span class="meta">@CookieValue(value="JSESSIONID", defaultValue="")</span> String jsessionid)</span> {</span><br><span class="line">    System.out.println(jsessionid);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"/index.jsp"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>获得转发Request域中的数据，在进行资源之间转发时，有时需要将一些参数存储到request域中携带给下一个资源</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping("request1")</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request1</span><span class="params">(HttpServletRequest request)</span> {</span><br><span class="line">    <span class="comment">// 存储数据</span></span><br><span class="line">    request.setAttribute(<span class="string">"username"</span>, <span class="string">"haohao"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"/request2"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping("/request2")</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">request2</span><span class="params">(<span class="meta">@RequestAttribute("username")</span> String username)</span> {</span><br><span class="line">    System.out.println(username);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"/index.jsp"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="请求静态资源"><a href="#请求静态资源" class="headerlink" title="请求静态资源"></a>请求静态资源</h4><p>静态资源请求的三种解决方案：</p>
<p>第一种方案，可以再次激活Tomcat的DefaultServlet，Servlet的url-pattern的匹配优先级是：精确匹配&gt;目录匹配&gt;扩展名匹配&gt;缺省匹配，所以可以指定某个目录下或某个扩展名的资源使用DefaultServlet进行解析：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/img/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>default<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.html<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>第二种方式，在spring-mvc.xml中去配置静态资源映射，匹配映射路径的请求到指定的位置去匹配资源</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mapping是映射资源路径，location是对应资源所在的位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/img/*"</span> <span class="attr">location</span>=<span class="string">"/img/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/css/*"</span> <span class="attr">location</span>=<span class="string">"/css/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/css/*"</span> <span class="attr">location</span>=<span class="string">"/js/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">"/img/*"</span> <span class="attr">location</span>=<span class="string">"/img/"</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>第三种方式，在spring-mvc.xml中去配置&lt;mvc:default-servlet-handler&gt;，该方式是注册了一个DefaultServletHttpRequestHandler处理器，静态资源的访问都由该处理器去处理。</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="注解驱动-lt-mvc-annotation-driven-gt-标签"><a href="#注解驱动-lt-mvc-annotation-driven-gt-标签" class="headerlink" title="注解驱动<mvc:annotation-driven>标签"></a>注解驱动&lt;mvc:annotation-driven&gt;标签</h2><p>Spring提供mvc:annotation-driven&gt;标签，该标签会自动注册RequestMappingHandlerMapping、RequestMappingHandlerApapter并注入Json消息转换器等。配置如下：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mvc注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置DefaultServletHttpRequestHandler--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="SpringMVC的响应处理"><a href="#SpringMVC的响应处理" class="headerlink" title="SpringMVC的响应处理"></a>SpringMVC的响应处理</h1><p>响应数据主要两种方式。</p>
<li>传统同步方式：准备好模型数据，跳转到执行页面进行展示，此方式使用越来越少。</li><li>前后端分离异步方式：前端使用Ajax技术+Restful风格与服务端进行Json格式为主的数据交互。</li><table>
    
    
</table>


<p><img src="/Users/yucan/blog/source/_posts/Spring/forward&amp;redirect-20231113095412247.png"></p>
<p>同步方式和异步方式响应数据的区别</p>
<li>同步方式回写数据，将数据响应给浏览器进行页面展示，而异步方式回写数据一般给Ajax引擎，即谁访问服务器端，服务器端就将数据相应给谁</li><li>同步方式回写的数据，一般是一些无特定格式的字符串，而异步方式回写的数据大多是Json格式字符串</li><table>
    
    
</table>


<h1 id="SpringMVC拦截器"><a href="#SpringMVC拦截器" class="headerlink" title="SpringMVC拦截器"></a>SpringMVC拦截器</h1><p>SpringMVC的拦截器Interface规范，主要是对Controller资源访问时进行拦截操作的技术。类似Javaweb开发中的Filter。</p>
<p><img src="/Users/yucan/blog/source/_posts/Spring/forward&amp;redirect-20231113095412247.png"></p>
<p>Filter与Interceptor对比</p>
<table>
<thead>
<tr>
<th></th>
<th>FIlter技术</th>
<th>Interceptor技术</th>
</tr>
</thead>
<tbody><tr>
<td>技术范畴</td>
<td>Javaweb原生技术</td>
<td>SpringMVC框架技术</td>
</tr>
<tr>
<td>拦截/过滤资源</td>
<td>可以对任何请求都过滤，包括任何Servlet、Jsp、其他资源等</td>
<td>只对进入了SpringMVC管辖范围的才拦截，主要拦截Controller请求</td>
</tr>
<tr>
<td>执行时机</td>
<td>早于任何Servlet执行</td>
<td>晚于DispatcherServlet执行</td>
</tr>
</tbody></table>
<p>Interceptor实现了HandlerInterceptor接口，且被Spring管理的Bean都是拦截器，HandlerInterceptor接口方法的作用及参数，返回值如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>作用</th>
<th>参数</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>preHandle</td>
<td>对拦截到的请求进行预处理，返回true放行执行处理器方法，false不放行</td>
<td>Handler是拦截到的Controller方法处理器</td>
<td>一旦返回false，代表终止向后执行，所有后置方法都不执行，最终方法只执行对应preHandler返回true的部分</td>
</tr>
<tr>
<td>postHandle</td>
<td>在处理器的方法执行后，对拦截到的请求进行后处理，可以在方法中对模型数据和视图进行修改</td>
<td>Handler是拦截到的Controller方法处理器；modelAndView是返回的模型视图对象</td>
<td>无</td>
</tr>
<tr>
<td>afterCompletion</td>
<td>视图渲染完成后，进行最后的处理，如果请求流程中有异常，可以处理异常对象</td>
<td>Handler是拦截到的Controller方法处理器；ex是异常对象</td>
<td>无</td>
</tr>
</tbody></table>
<p><img src="/Users/yucan/blog/source/_posts/Spring/interceptor%E9%A1%BA%E5%BA%8F-20231113095412305.png"></p>
<p><img src="/Users/yucan/blog/source/_posts/Spring/interceptor%E5%8E%9F%E7%90%86-20231113095412296.png"></p>
</body></html>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/JavaWeb/" rel="tag"># JavaWeb</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/11/10/redis-principle/" rel="prev" title="Redis_Principle">
      <i class="fa fa-chevron-left"></i> Redis_Principle
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/11/21/JVM/" rel="next" title="JVM">
      JVM <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9FJavaWeb%E5%BC%80%E5%8F%91%E5%9B%B0%E6%83%91%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">1.</span> <span class="nav-text">传统JavaWeb开发困惑与解决方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E6%80%9D%E6%83%B3"><span class="nav-number">2.</span> <span class="nav-text">三种思想</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Bean%E7%9A%84%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3"><span class="nav-number">3.</span> <span class="nav-text">Spring-Bean的配置详解</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean-id"><span class="nav-number">3.1.</span> <span class="nav-text">Bean-id</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean-name"><span class="nav-number">3.2.</span> <span class="nav-text">Bean-name</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean-scope"><span class="nav-number">3.3.</span> <span class="nav-text">Bean-scope</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean-lazy-init"><span class="nav-number">3.4.</span> <span class="nav-text">Bean-lazy-init</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E9%94%80%E6%AF%81%E6%96%B9%E6%B3%95%E9%85%8D%E7%BD%AE"><span class="nav-number">3.5.</span> <span class="nav-text">Bean的初始化和销毁方法配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E7%9A%84%E5%AE%9E%E4%BE%8B%E5%8C%96%E8%AE%BE%E7%BD%AE"><span class="nav-number">3.6.</span> <span class="nav-text">Bean的实例化设置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E9%85%8D%E7%BD%AE"><span class="nav-number">3.7.</span> <span class="nav-text">Bean的依赖注入配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Bean%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D"><span class="nav-number">3.7.1.</span> <span class="nav-text">Bean自动装配</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E7%9A%84%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE%E6%A0%87%E7%AD%BE"><span class="nav-number">4.</span> <span class="nav-text">Spring的其他配置标签</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#beans-profile"><span class="nav-number">4.0.1.</span> <span class="nav-text">beans-profile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#beans-import"><span class="nav-number">4.0.2.</span> <span class="nav-text">beans-import</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#beans-alias"><span class="nav-number">4.0.3.</span> <span class="nav-text">beans-alias</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E7%9A%84get%E6%96%B9%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">Spring的get方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E9%85%8D%E7%BD%AE%E9%9D%9E%E8%87%AA%E5%AE%9A%E4%B9%89Bean"><span class="nav-number">6.</span> <span class="nav-text">Spring配置非自定义Bean</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Bean%E5%AE%9E%E4%BE%8B%E5%8C%96%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">Bean实例化的基本流程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8"><span class="nav-number">8.</span> <span class="nav-text">Spring后处理器</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E5%B7%A5%E5%8E%82%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8-BeanFactoryPostProcessor"><span class="nav-number">8.1.</span> <span class="nav-text">Bean工厂后处理器-BeanFactoryPostProcessor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E5%90%8E%E5%A4%84%E7%90%86%E5%99%A8-BeanPostProcessor"><span class="nav-number">8.2.</span> <span class="nav-text">Bean后处理器-BeanPostProcessor</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring-Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">9.</span> <span class="nav-text">Spring Bean的生命周期</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E6%95%B4%E5%90%88MyBatis"><span class="nav-number">10.</span> <span class="nav-text">Spring整合MyBatis</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E6%95%B4%E5%90%88%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6"><span class="nav-number">11.</span> <span class="nav-text">Spring整合第三方框架</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E7%9A%84Spring%E5%BC%80%E5%8F%91"><span class="nav-number">12.</span> <span class="nav-text">基于注解的Spring开发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="nav-number">12.1.</span> <span class="nav-text">Bean基本注解开发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="nav-number">12.2.</span> <span class="nav-text">Bean依赖注入注解开发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%9E%E8%87%AA%E5%AE%9A%E4%B9%89Bean%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="nav-number">12.3.</span> <span class="nav-text">非自定义Bean注解开发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bean%E9%85%8D%E7%BD%AE%E7%B1%BB%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91"><span class="nav-number">12.4.</span> <span class="nav-text">Bean配置类的注解开发</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%B3%A8%E8%A7%A3%E7%9A%84%E8%A7%A3%E6%9E%90%E5%8E%9F%E7%90%86"><span class="nav-number">12.5.</span> <span class="nav-text">Spring注解的解析原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%B3%A8%E8%A7%A3%E6%96%B9%E5%BC%8F%E6%95%B4%E5%90%88%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6"><span class="nav-number">12.6.</span> <span class="nav-text">Spring注解方式整合第三方框架</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AOP"><span class="nav-number">13.</span> <span class="nav-text">AOP</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">13.1.</span> <span class="nav-text">AOP的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP%E6%80%9D%E6%83%B3%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="nav-number">13.2.</span> <span class="nav-text">AOP思想的实现方案</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AOP%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">13.3.</span> <span class="nav-text">AOP相关概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Exml%E9%85%8D%E7%BD%AEAOP"><span class="nav-number">13.4.</span> <span class="nav-text">基于xml配置AOP</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Spring%E6%95%B4%E5%90%88web%E7%8E%AF%E5%A2%83"><span class="nav-number">14.</span> <span class="nav-text">Spring整合web环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Javaweb%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%97%AE%E9%A2%98"><span class="nav-number">14.1.</span> <span class="nav-text">Javaweb三大组件及环境问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring%E6%95%B4%E5%90%88web%E7%8E%AF%E5%A2%83%E7%9A%84%E6%80%9D%E8%B7%AF%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">14.2.</span> <span class="nav-text">Spring整合web环境的思路及实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MVC%E6%A1%86%E6%9E%B6%E6%80%9D%E6%83%B3%E5%8F%8A%E5%85%B6%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="nav-number">14.3.</span> <span class="nav-text">MVC框架思想及其设计思路</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringMVC%E7%AE%80%E4%BB%8B"><span class="nav-number">15.</span> <span class="nav-text">SpringMVC简介</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">15.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B7%E4%BD%93%E9%85%8D%E7%BD%AE"><span class="nav-number">15.2.</span> <span class="nav-text">具体配置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6"><span class="nav-number">15.3.</span> <span class="nav-text">SpringMVC关键组件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringMVC%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86"><span class="nav-number">15.4.</span> <span class="nav-text">SpringMVC的请求处理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E8%B7%AF%E5%BE%84%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="nav-number">15.4.1.</span> <span class="nav-text">请求映射路径的配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8E%A5%E6%94%B6"><span class="nav-number">15.4.2.</span> <span class="nav-text">请求数据的接收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6JSON%E8%AF%B7%E6%B1%82%E4%BD%93"><span class="nav-number">15.4.2.1.</span> <span class="nav-text">接收JSON请求体</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6Restful%E9%A3%8E%E6%A0%BC%E6%95%B0%E6%8D%AE"><span class="nav-number">15.4.2.2.</span> <span class="nav-text">接收Restful风格数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8E%A5%E6%94%B6%E6%96%87%E4%BB%B6"><span class="nav-number">15.4.2.3.</span> <span class="nav-text">接收文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B7%E6%B1%82%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90"><span class="nav-number">15.4.2.4.</span> <span class="nav-text">请求静态资源</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8-lt-mvc-annotation-driven-gt-%E6%A0%87%E7%AD%BE"><span class="nav-number">15.5.</span> <span class="nav-text">注解驱动&lt;mvc:annotation-driven&gt;标签</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringMVC%E7%9A%84%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86"><span class="nav-number">16.</span> <span class="nav-text">SpringMVC的响应处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringMVC%E6%8B%A6%E6%88%AA%E5%99%A8"><span class="nav-number">17.</span> <span class="nav-text">SpringMVC拦截器</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MANVND</p>
  <div class="site-description" itemprop="description">There is no royal road to learning</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MANVND</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
