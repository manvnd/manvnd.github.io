<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Redis基础使用NoSQL特性 数据结构：数据往往以非结构化的方式存储 数据关联：无关联的 查询方式：非SQL语句查询 事务特性：无法满足ACID，而是BASE 存储方式：内存 拓展性：水平  Redis特性基于内存的键值型NoSQL数据库。  键值型，value支持多种不同数据结构，功能丰富； 单线程，每个命令具备原子性 低延迟，速度快（基于内存、IO多路复用、良好的编码） 支持数据持久化 支">
<meta property="og:type" content="article">
<meta property="og:title" content="redis">
<meta property="og:url" content="http://example.com/2023/08/09/Redis/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Redis基础使用NoSQL特性 数据结构：数据往往以非结构化的方式存储 数据关联：无关联的 查询方式：非SQL语句查询 事务特性：无法满足ACID，而是BASE 存储方式：内存 拓展性：水平  Redis特性基于内存的键值型NoSQL数据库。  键值型，value支持多种不同数据结构，功能丰富； 单线程，每个命令具备原子性 低延迟，速度快（基于内存、IO多路复用、良好的编码） 支持数据持久化 支">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://rxvukhxe6.hn-bkt.clouddn.com/%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95.png">
<meta property="og:image" content="http://rxvukhxe6.hn-bkt.clouddn.com/%E6%B7%BB%E5%8A%A0Redis%E7%BC%93%E5%AD%98.png">
<meta property="og:image" content="http://rxvukhxe6.hn-bkt.clouddn.com/%E4%BA%92%E6%96%A5%E9%94%81.png">
<meta property="og:image" content="http://rxvukhxe6.hn-bkt.clouddn.com/%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F.png">
<meta property="article:published_time" content="2023-08-09T11:53:07.102Z">
<meta property="article:modified_time" content="2023-08-24T06:37:05.402Z">
<meta property="article:author" content="MANVND">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://rxvukhxe6.hn-bkt.clouddn.com/%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95.png">

<link rel="canonical" href="http://example.com/2023/08/09/Redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>redis | Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/08/09/Redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="MANVND">
      <meta itemprop="description" content="There is no royal road to learning">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          redis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-09 19:53:07" itemprop="dateCreated datePublished" datetime="2023-08-09T19:53:07+08:00">2023-08-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-08-24 14:37:05" itemprop="dateModified" datetime="2023-08-24T14:37:05+08:00">2023-08-24</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="Redis基础使用"><a href="#Redis基础使用" class="headerlink" title="Redis基础使用"></a>Redis基础使用</h1><h2 id="NoSQL特性"><a href="#NoSQL特性" class="headerlink" title="NoSQL特性"></a>NoSQL特性</h2><ul>
<li>数据结构：数据往往以非结构化的方式存储</li>
<li>数据关联：无关联的</li>
<li>查询方式：非SQL语句查询</li>
<li>事务特性：无法满足ACID，而是BASE</li>
<li>存储方式：内存</li>
<li>拓展性：水平</li>
</ul>
<h2 id="Redis特性"><a href="#Redis特性" class="headerlink" title="Redis特性"></a>Redis特性</h2><p>基于<strong>内存</strong>的键值型NoSQL数据库。</p>
<ul>
<li>键值型，value支持多种不同数据结构，功能丰富；</li>
<li>单线程，每个命令具备原子性</li>
<li>低延迟，速度快（基于内存、IO多路复用、良好的编码）</li>
<li>支持数据持久化</li>
<li>支持主从集群、分片集群</li>
</ul>
<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis是一个key-value数据库，key一般是String类型，value的类型多种多样：</p>
<p>String, Hash, List, Set, SortedSet, GEO, BitMap, HyperLog</p>
<h2 id="Redis通用命令"><a href="#Redis通用命令" class="headerlink" title="Redis通用命令"></a>Redis通用命令</h2><p>通用命令是不分数据类型的，都可以使用的指令，常见的有：</p>
<ul>
<li>KEYS：查看符合模板的所有key，后接匹配模式pattern，不建议在生产环境设备上使用</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">KEYS *</span><br></pre></td></tr></table></figure>

<ul>
<li>DEL：删除一个指定key，后接一个或多个key的名称</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL keyName</span><br></pre></td></tr></table></figure>

<ul>
<li>EXISTS：查看一个key是否存在，后接key的名称</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXISTS keyName</span><br></pre></td></tr></table></figure>

<ul>
<li>EXPIRE：给一个key设置有效期，有效期到期key会自动被删除</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE keyName time</span><br></pre></td></tr></table></figure>

<ul>
<li>TTL：查看一个key的剩余有效期</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TTL keyName</span><br></pre></td></tr></table></figure>

<p>可以通过help[command]查看一个命令的具体用法。</p>
<h2 id="String类型命令"><a href="#String类型命令" class="headerlink" title="String类型命令"></a>String类型命令</h2><p>String类型是Redis中最简单的存储类型。其value是字符串，但根据字符串的格式不同，可以分为三类：</p>
<ul>
<li>string：普通字符串</li>
<li>int：整数类型，可以做自增、自减操作</li>
<li>float：浮点类型，可以做自增、自减操作</li>
</ul>
<p>不管哪种格式，其底层都是用<strong>字节数组</strong>形式存储，只不过编码方式不同。字符串类型的最大空间不能超过512m。</p>
<p>String的常见命令有：</p>
<ul>
<li>SET：添加或修改已经存在的一个String类型的键值对</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [NX | XX] [GET] [EX seconds | PX milliseconds | EXAT unix-time-seconds | PXAT unix-time-milliseconds | KEEPTTL]</span><br></pre></td></tr></table></figure>

<ul>
<li>GET：根据key获取String类型的value</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET key</span><br></pre></td></tr></table></figure>

<ul>
<li>MSET：批量添加多个String类型的键值对</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>MGET：根据多个key获取多个String类型的value</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MGET key [key ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>INCR：让一个整形的key的值自增1</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCR key</span><br></pre></td></tr></table></figure>

<ul>
<li>INCRBY：让一个整形的key的值自增并指定步长</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBY key increment</span><br></pre></td></tr></table></figure>

<ul>
<li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INCRBYFLOAT key increment</span><br></pre></td></tr></table></figure>

<ul>
<li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX key value</span><br></pre></td></tr></table></figure>

<ul>
<li>SETEX：添加一个String类型的键值对，并且指定有效期</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETEX key seconds value</span><br></pre></td></tr></table></figure>

<h2 id="key的结构"><a href="#key的结构" class="headerlink" title="key的结构"></a>key的结构</h2><p>Redis的key允许多个单词形成层级结构，多个单词之间用’.’隔开，格式如下：</p>
<p>项目名:业务名:类型:id</p>
<h2 id="Hash类型命令"><a href="#Hash类型命令" class="headerlink" title="Hash类型命令"></a>Hash类型命令</h2><p>Hash类型，也叫散列，其value是一个无序字，类似于Java中的HashMap结构。</p>
<p>Hash结构可以将对象中的每个字段独立存储，可以针对单个字段做CRUD。</p>
<table>
  <tbody text-align="center">
    <tr>
        <th rowspan=2>KEY</th>
      <th colspan=2>VALUE</th>
    </tr>
      <tr>
        <td>field</td>
      <td>value</td>
    </tr>
  </tbody>
</table>

<p>Hash类型的常见命令：</p>
<ul>
<li>HSET: 添加或修改hash类型key的field的值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSET key field value</span><br></pre></td></tr></table></figure>

<ul>
<li>HGSET：获取一个hash类型key的filed的值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGET key field</span><br></pre></td></tr></table></figure>

<ul>
<li>HMSET：批量添加多个hash类型key的field的值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMSET key field value [field value ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>HMGET：批量获取多个hash类型key的field的值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMGET key field [field ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>HGETALL：获取一个hash类型的key中的所有field和value</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HGETALL key</span><br></pre></td></tr></table></figure>

<ul>
<li>HKEYS：获取一个hash类型的key中所有的field</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HKEYS key</span><br></pre></td></tr></table></figure>

<ul>
<li>HVALS：获取一个hash类型的key中的所有value</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HVALS key</span><br></pre></td></tr></table></figure>

<ul>
<li>HINCRBY：让一个hash类型key的字段值自增并指定步长</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HINCRBY key field increment</span><br></pre></td></tr></table></figure>

<ul>
<li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HSETNX key field value</span><br></pre></td></tr></table></figure>

<h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>Redis中的List类型与Java中的LinkedList类似，可以看做一个双向链表结构。既可以正向检索也可以反向检索</p>
<p>特征：</p>
<ul>
<li>有序</li>
<li>元素可以重复插入</li>
<li>插入和删除块</li>
<li>查询速度一般</li>
</ul>
<p>常用来存储一个有序数据</p>
<p>List的常见命令有：</p>
<ul>
<li>LPUSH：向列表左侧插入一个或多个元素</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPUSH key element [element ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>LPOP：移除并返回列表左侧的第一个元素，没有返回null</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LPOP key [count]</span><br></pre></td></tr></table></figure>

<ul>
<li>RPUSH：向列表右侧插入一个或多个元素</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSH key element [element ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>RPOP：移除并返回列表右侧第一个元素</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPOP key [count]</span><br></pre></td></tr></table></figure>

<ul>
<li>LRANGE：返回一段角标范围内的所有元素</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LRANGE key start stop</span><br></pre></td></tr></table></figure>

<ul>
<li>BLPOP与BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回null</li>
</ul>
<h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具有与HashSet类似的特征：</p>
<ul>
<li>无序</li>
<li>元素不可重复</li>
<li>查找快</li>
<li>支持交集、并集、差集等功能</li>
</ul>
<p>Set的常见命令有：</p>
<ul>
<li>SADD：向set中添加一个或多个元素</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SADD key member [member ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>SREM：移除set中的指定元素</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SREM key member [member ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>SCARD：返回set中元素的个数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SCARD key</span><br></pre></td></tr></table></figure>

<ul>
<li>SISMEMBER：判断一个元素是否存在于set中</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SISMEMBER key member</span><br></pre></td></tr></table></figure>

<ul>
<li>SMEMBERS：获取set中的所有元素</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SMEMBERS key</span><br></pre></td></tr></table></figure>

<ul>
<li>SINTER：求key1与key2的交集</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SINTER key [key ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>SDIFF：求key1与key2的差集</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SDIFF key [key ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>SUNION：求key1与key2的并集</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUNION key [key ...]</span><br></pre></td></tr></table></figure>

<h2 id="SortedSet类型"><a href="#SortedSet类型" class="headerlink" title="SortedSet类型"></a>SortedSet类型</h2><p>Redis的Sorted是一个可排序的set集合，与Java中的TreeSet功能类似，但底层数据结构差别很大。SortedSet中的每个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表加hash表</p>
<p>SortedSet具有以下特性：</p>
<ul>
<li>可排序</li>
<li>元素不重复</li>
<li>查询速度快</li>
</ul>
<p>SortedSet的常见命令有：</p>
<ul>
<li>ZADD：添加一个或多个元素到sorted set，如果已经存在则更新其score值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>ZREM：删除sorted set中的一个指定元素</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZREM key member [member ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>ZSCORE：获取sorted set中的指定元素的score值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSCORE key member</span><br></pre></td></tr></table></figure>

<ul>
<li>ZRANK：获取sorted set中的指定元素的排名</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANK key member [WITHSCORE]</span><br></pre></td></tr></table></figure>

<ul>
<li>ZCARD：获取sorted set 中的元素个数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCARD key</span><br></pre></td></tr></table></figure>

<ul>
<li>ZCOUNT：统计score值在给定范围内的所有元素的个数</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZCOUNT key min max</span><br></pre></td></tr></table></figure>

<ul>
<li>ZINCRBY：让sorted set中的指定元素自增，步长为指定的increment值</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZINCRBY key increment member</span><br></pre></td></tr></table></figure>

<ul>
<li>ZRANGE：按照score排序后，获取指定排名范围内的元素</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count] [WITHSCORES]</span><br></pre></td></tr></table></figure>

<ul>
<li>ZRANGEBYSCORE：按照score排序后，获取指定score范围内的元素</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]</span><br></pre></td></tr></table></figure>

<ul>
<li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li>
</ul>
<p>所有排名默认升序，如果要降序则在命令Z后添加<strong>REV</strong>即可</p>
<h1 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h1><p>Jedis本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此可以使用Jedis连接池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        JedisPoolConfig jedisPoolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        jedisPoolConfig.setMaxTotal(<span class="number">8</span>);</span><br><span class="line">        jedisPoolConfig.setMaxIdle(<span class="number">8</span>);</span><br><span class="line">        jedisPoolConfig.setMinIdle(<span class="number">0</span>);</span><br><span class="line">        jedisPoolConfig.setMaxWait(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(jedisPoolConfig, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6379</span>, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedisPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="SpringDataRedis"><a href="#SpringDataRedis" class="headerlink" title="SpringDataRedis"></a>SpringDataRedis</h1><p>SpringData是Spring中数据操作的模块，包含对各种数据库的集成，其中对Redis的集成模块就叫SpringDataRedis</p>
<ul>
<li>提供了对不同Redis客户端的整合</li>
<li>提供了RedisTemplate统一API来操作Redis</li>
<li>支持Redis的发布订阅模型</li>
<li>支持Redis哨兵和Redis集群</li>
<li>支持基于Lettuce的响应式编程</li>
<li>支持给予JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li>
<li>支持基于Redis的JDKCollection实现</li>
</ul>
<h2 id="SpringDataRedis快速使用"><a href="#SpringDataRedis快速使用" class="headerlink" title="SpringDataRedis快速使用"></a>SpringDataRedis快速使用</h2><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并将不同数据类型的操作API封装到了不同的类型中</p>
<table>
<thead>
<tr>
<th align="center">API</th>
<th align="center">返回值类型</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">redisTemplate.opsForValue()</td>
<td align="center">ValueOperations</td>
<td align="center">操作String类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate.opsForHash()</td>
<td align="center">HashOperatiions</td>
<td align="center">操作Hash类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate.opsForList()</td>
<td align="center">ListOperations</td>
<td align="center">操作List类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate.opsForSet()</td>
<td align="center">SetOperations</td>
<td align="center">操作Set类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate.opsForZSet()</td>
<td align="center">ZSetOperations</td>
<td align="center">操作SortedSet类型数据</td>
</tr>
<tr>
<td align="center">redisTemplate</td>
<td align="center"></td>
<td align="center">通用的命令</td>
</tr>
</tbody></table>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.commons/commons-pool2 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">    <span class="attr">redis:</span></span><br><span class="line">      <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">      <span class="attr">lettuce:</span></span><br><span class="line">        <span class="attr">pool:</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment"># 最大连接</span></span><br><span class="line">          <span class="attr">max-idle:</span> <span class="number">8</span> <span class="comment"># 最大空闲连接</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">0</span> <span class="comment"># 最小空闲连接</span></span><br><span class="line">          <span class="attr">max-wait:</span> <span class="number">100</span> <span class="comment"># 连接等待时间</span></span><br></pre></td></tr></table></figure>

<h3 id="注入RedisTemplate"><a href="#注入RedisTemplate" class="headerlink" title="注入RedisTemplate"></a>注入RedisTemplate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> REdisTemplate redisTemplate</span><br></pre></td></tr></table></figure>

<h2 id="SpringDataRedis的序列化方式"><a href="#SpringDataRedis的序列化方式" class="headerlink" title="SpringDataRedis的序列化方式"></a>SpringDataRedis的序列化方式</h2><p>RedisTemplate可以接收任意Object作为值写入Redis，只不过写入前会把Object序列化为字节形式，默认采用JDK序列化</p>
<p>缺点：</p>
<ul>
<li>可读性差</li>
<li>内存占用较大</li>
</ul>
<p>可以自定义RedisTemplate的序列化方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建RedisTemplate对象</span></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        <span class="comment">// 设置连接工厂</span></span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line">        <span class="comment">// 设置Key的序列化</span></span><br><span class="line">        template.setKeySerializer(RedisSerializer.string());</span><br><span class="line">        template.setHashKeySerializer(RedisSerializer.string());</span><br><span class="line">        <span class="comment">// 设置value的序列化</span></span><br><span class="line">        template.setValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        template.setHashValueSerializer(<span class="keyword">new</span> GenericJackson2JsonRedisSerializer());</span><br><span class="line">        <span class="comment">// 返回</span></span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>为了实现序列化与反序列化，Template会在Redis数据库中存储”@Class”保存该数据的类，但因此也会产生额外的内存开销</p>
<p>为了节省空间，一般不会用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化</p>
<p>Spring默认提供一个StringRedisTemplate类，它的key和value的序列化默认就是String方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSaveUser</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建对象</span></span><br><span class="line">        User user = <span class="keyword">new</span> User(<span class="string">&quot;虎哥&quot;</span>, <span class="number">21</span>);</span><br><span class="line">        <span class="comment">// 手动序列化</span></span><br><span class="line">        String json = mapper.writeValueAsString(user);</span><br><span class="line">        <span class="comment">// 写入数据</span></span><br><span class="line">        stringRedisTemplate.opsForValue().set(<span class="string">&quot;user:100&quot;</span>, json);</span><br><span class="line">        <span class="comment">// 获取数据</span></span><br><span class="line">        String jsonUser = stringRedisTemplate.opsForValue().get(<span class="string">&quot;user:100&quot;</span>);</span><br><span class="line">        <span class="comment">// 手动反序列化</span></span><br><span class="line">        User user1 = mapper.readValue(jsonUser, User.class);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h2 id="Session实现用户短信登录"><a href="#Session实现用户短信登录" class="headerlink" title="Session实现用户短信登录"></a>Session实现用户短信登录</h2><p><img src="http://rxvukhxe6.hn-bkt.clouddn.com/%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95.png"></p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="缓存的简介"><a href="#缓存的简介" class="headerlink" title="缓存的简介"></a>缓存的简介</h3><p><strong>缓存</strong>就是数据交换的缓冲区，是存储数据的临时地方，一般读写性能较高。</p>
<p>浏览器：浏览器缓存</p>
<p>tomcat：应用层缓存</p>
<p>数据库：数据库缓存</p>
<p>作用：</p>
<ul>
<li>降低后端负载</li>
<li>提高读写效率，降低响应时间</li>
</ul>
<p>成本：</p>
<ul>
<li>数据一致性成本</li>
<li>代码维护成本</li>
<li>运维成本</li>
</ul>
<h3 id="添加Redis缓存"><a href="#添加Redis缓存" class="headerlink" title="添加Redis缓存"></a>添加Redis缓存</h3><p><img src="http://rxvukhxe6.hn-bkt.clouddn.com/%E6%B7%BB%E5%8A%A0Redis%E7%BC%93%E5%AD%98.png"></p>
<h3 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h3><table>
<thead>
<tr>
<th></th>
<th>内存淘汰</th>
<th>超时剔除</th>
<th>主动更新</th>
</tr>
</thead>
<tbody><tr>
<td><strong>说明</strong></td>
<td>不用自己维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据。下次查询时更新缓存</td>
<td>给缓存数据添加TTL时间，到期后自动删除缓存。下次查询时更新缓存</td>
<td>编写业务逻辑，在修改数据库的同时，更新缓存</td>
</tr>
<tr>
<td><strong>一致性</strong></td>
<td>差</td>
<td>一般</td>
<td>好</td>
</tr>
<tr>
<td><strong>维护成本</strong></td>
<td>无</td>
<td>低</td>
<td>高</td>
</tr>
</tbody></table>
<h3 id="主动更新策略"><a href="#主动更新策略" class="headerlink" title="主动更新策略"></a>主动更新策略</h3><ol>
<li>由缓存的调用者，在更新数据库的同时更新缓存</li>
</ol>
<ul>
<li>删除缓存：更新数据库时让缓存失效，查询时再更新缓存</li>
<li>单体系统：将缓存与数据库操作放在一个事务；分布式系统，利用TTC等分布式事务方案</li>
</ul>
<ol>
<li>缓存与数据库整合为一个服务，由服务来维护一致性。调用者调用该服务，无需关心缓存一致性问题</li>
<li>调用者只操作缓存，由其他线程异步的将缓存数据持久化到数据库，保持最终一致</li>
</ol>
<p>最佳实践方案：</p>
<ol>
<li>低一致性需求：使用Redis自带的内存淘汰机制</li>
<li>高一致性需求：主动更新，并以超时剔除作为兜底方案</li>
</ol>
<ul>
<li>读操作：<ul>
<li>缓存命中则直接返回</li>
<li>缓存命中则查询数据库，并写入缓存，设定超时时间</li>
</ul>
</li>
<li>写操作：<ul>
<li>先写数据库，然后再删除缓存</li>
<li>要确保数据库与缓存操作的原子性</li>
</ul>
</li>
</ul>
<h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p><strong>缓存穿透</strong>是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都回到数据库</p>
<ul>
<li>缓存空对象：当将空对象存储在缓存中<ul>
<li>优点：实现简单，维护方便</li>
<li>缺点：<ul>
<li>额外的内存消耗</li>
<li>可能造成短期的不一致</li>
</ul>
</li>
</ul>
</li>
<li>布隆过滤：在客户端与缓存间添加一层——布隆过滤器<ul>
<li>优点：内存占用较少，没有多余key</li>
<li>缺点：<ul>
<li>实现复杂</li>
<li>存在误判可能</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p><strong>缓存雪崩</strong>指同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力</p>
<p>解决方案：</p>
<ul>
<li>给不同key的TTL添加随机值</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给缓存业务天假降级限流策略</li>
<li>给业务添加多级缓存</li>
</ul>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p><strong>缓存击穿问题</strong>也叫热点key问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数的请求会在瞬间给数据库带来巨大的冲击</p>
<p>常见解决方案：</p>
<ul>
<li>互斥锁</li>
</ul>
<p><img src="http://rxvukhxe6.hn-bkt.clouddn.com/%E4%BA%92%E6%96%A5%E9%94%81.png"></p>
<ul>
<li>逻辑过期</li>
</ul>
<p><img src="http://rxvukhxe6.hn-bkt.clouddn.com/%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F.png"></p>
<table>
<thead>
<tr>
<th>解决方案</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>互斥锁</td>
<td>- 没有额外的内存消耗<br>- 保证一致性<br>- 实现简单</td>
<td>- 线程需要等待，性能受到影响 <br>- 可能有死锁风险</td>
</tr>
<tr>
<td>逻辑过期</td>
<td>- 线程无需等待，性能较好</td>
<td>- 不保证一致性<br>- 有额外的内存消耗<br>- 实现复杂</td>
</tr>
</tbody></table>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><ul>
<li><p>悲观锁：认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。</p>
</li>
<li><p>乐观锁：认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其他线程对数据做了修改。</p>
<ul>
<li>如果没有修改则认为是安全的，自己才更新数据；</li>
<li>如果已经被其他线程修改说明发生了安全问题，此时可以重试或异常</li>
</ul>
</li>
</ul>
<h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>乐观锁的关键是判断之前查询得到的数据是否有被修改过</p>
<h4 id="CAS法"><a href="#CAS法" class="headerlink" title="CAS法"></a>CAS法</h4><p>给数据添加版本号，根据版本号是否变化判断是否有别的线程修改了数据</p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁</p>
<p>分布式锁的核心是实现多进程之间的互斥，而满足这一点的方式有很多，常见的有三种：</p>
<table>
<thead>
<tr>
<th></th>
<th>MySQL</th>
<th>Redis</th>
<th>Zookeeper</th>
</tr>
</thead>
<tbody><tr>
<td>互斥</td>
<td>利用MySQL本身的互斥锁机制</td>
<td>利用setnx这样的互斥命令</td>
<td>利用节点的唯一性和有序性实现互斥</td>
</tr>
<tr>
<td>高可用</td>
<td>好</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>高性能</td>
<td>一般</td>
<td>好</td>
<td>一般</td>
</tr>
<tr>
<td>安全性</td>
<td>断开连接，自动释放锁</td>
<td>利用锁超时时间，到期释放</td>
<td>临时节点，断开连接自动释放</td>
</tr>
</tbody></table>
<h4 id="基于Redis的分布式锁"><a href="#基于Redis的分布式锁" class="headerlink" title="基于Redis的分布式锁"></a>基于Redis的分布式锁</h4><p>实现分布式锁时需要实现的两个基本方法：</p>
<ul>
<li>获取锁：<ul>
<li>互斥：确保只能有一个线程获取锁</li>
</ul>
</li>
<li>释放锁：<ul>
<li>手动释放</li>
<li>超时释放：获取锁时添加一个超时时间</li>
</ul>
</li>
</ul>
<h4 id="改进Redis的分布式锁"><a href="#改进Redis的分布式锁" class="headerlink" title="改进Redis的分布式锁"></a>改进Redis的分布式锁</h4><ol>
<li>在获取锁时存入线程标识；</li>
<li>在释放锁时先获取锁的线程标识，判断是否与当前线程标识一致<ul>
<li>如果一致则释放锁</li>
<li>如果不一致则不释放锁</li>
</ul>
</li>
</ol>
<h4 id="Redis的Lua脚本"><a href="#Redis的Lua脚本" class="headerlink" title="Redis的Lua脚本"></a>Redis的Lua脚本</h4><p>Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。</p>
<h2 id="Redisson"><a href="#Redisson" class="headerlink" title="Redisson"></a>Redisson</h2><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包括了各种分布式锁的实现</p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedissonClient <span class="title">redissonClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 配置类</span></span><br><span class="line">        Config config = <span class="keyword">new</span> Config();</span><br><span class="line">        <span class="comment">// 添加redis地址，这里添加单点地址，也可以使用config.useClusterServers()添加集群地址</span></span><br><span class="line">        config.useSingleServer().setAddress(<span class="string">&quot;redis://127.0.0.1:6379&quot;</span>);</span><br><span class="line">        <span class="comment">// 创建客户端</span></span><br><span class="line">        <span class="keyword">return</span> Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Redisson可重入锁的原理"><a href="#Redisson可重入锁的原理" class="headerlink" title="Redisson可重入锁的原理"></a>Redisson可重入锁的原理</h3><p>![](/Users/yucan/Documents/文稿 - yucan’s MacBook Pro/Markdown/IMG/Redisson可重入锁原理.png)</p>
<p>使用Lua脚本完成上图逻辑保证原子性</p>
<h3 id="Redisson分布式的原理"><a href="#Redisson分布式的原理" class="headerlink" title="Redisson分布式的原理"></a>Redisson分布式的原理</h3><ul>
<li><strong>可重入</strong>： 利用hash结构记录线程id和重入次数</li>
<li><strong>可重试</strong>：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</li>
<li><strong>超时续约</strong>：利用watchDog，每隔一段时间（realeaseTime / 3），重置超时时间</li>
</ul>
<h3 id="Redisson分布式锁主从一致性问题"><a href="#Redisson分布式锁主从一致性问题" class="headerlink" title="Redisson分布式锁主从一致性问题"></a>Redisson分布式锁主从一致性问题</h3><p>主从模式：主节点处理写操作，从节点处理读操作</p>
<p>一致性问题：主操作更新的数据还没来得及同步到从节点，此时发生一致性问题</p>
<p>Redisson取消主从模式，所有节点均为主节点，一个应用要同时获取多个节点的锁才能获取读写操作</p>
<p>Redisson的multiLock：多个独立的Redis节点，必须在所有节点都获取重入锁，才算获取锁成功；缺陷：运维成本高，实现复杂</p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列(Message Queue)，即存放消息的队列。最简单的消息队列模型包括3个角色：</p>
<ul>
<li>消息队列：存储和管理消息，也被称为消息代理；</li>
<li>生产者：发送消息到消息队列；</li>
<li>消费者：从消息队列获取消息并处理消息；</li>
</ul>
<p>Redis提供三种不同的方式来实现消息队列：</p>
<ul>
<li>list结构：基于list结构模拟消息队列</li>
<li>PubSub：基本的点对点消息模型</li>
<li>Stream：比较完善的消息队列模型</li>
</ul>
<h3 id="基于List结构模拟消息队列"><a href="#基于List结构模拟消息队列" class="headerlink" title="基于List结构模拟消息队列"></a>基于List结构模拟消息队列</h3><p>队列的入口和出口不在一边，因此可以利用LPUSH结合RPOP、或者RPUSH结合LPOP来实现，不过，当队列中没有消息的时候RPOP或LPLP操作会返回null，并不会像JVM的阻塞队列那样阻塞并等待消息，因此应该使用<strong>BRPOP</strong>或者<strong>BLPOP</strong>来实现阻塞效果</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>基于Redis存储，不受限于JVM内存上限</li>
<li>基于Redis的持久化机制，数据安全性有保证</li>
<li>可以满足消息有序性</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>无法避免消息丢失</li>
<li>只支持单消费者</li>
</ul>
<h3 id="基于PubSub的消息队列"><a href="#基于PubSub的消息队列" class="headerlink" title="基于PubSub的消息队列"></a>基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息</p>
<ul>
<li>SUBSCRIBE channel [channel]: 订阅一个或多个频道</li>
<li>PUBLISH channel msg: 向一个频道发送消息</li>
<li>PSUBSCRIBE pattern [pattern]: 订阅与pattern格式匹配的所有频道</li>
</ul>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>采用发布订阅模型，支持多生产，多消费</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>不支持数据持久化</li>
<li>无法避免消息丢失</li>
<li>消息堆积有上限，超出时数据丢失</li>
</ul>
<h3 id="基于Stream的消息队列"><a href="#基于Stream的消息队列" class="headerlink" title="基于Stream的消息队列"></a>基于Stream的消息队列</h3><p>Stream是Redis5.0引入的一种新数据类型，可以实现一个功能非常完善的消息队列</p>
<p>发送消息的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XADD key [NOMKSTREAM] [MAXLEN|MINID [=|~] threshold [LIMIT count]] *|ID field value [field value ...]</span><br></pre></td></tr></table></figure>

<p>读取消息的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREAD [COUNT count] [BLOCK milliseconds] [STREAMS key [key ...] ID [ID ...]]</span><br></pre></td></tr></table></figure>

<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>消息可回溯</li>
<li>一个消息可以被多个消费者读取</li>
<li>可以阻塞读取</li>
<li>有消息漏读的风险</li>
</ul>
<h3 id="基于Stream的消息队列-消费者组"><a href="#基于Stream的消息队列-消费者组" class="headerlink" title="基于Stream的消息队列-消费者组"></a>基于Stream的消息队列-消费者组</h3><p>消费者组：将对个消费者划分到一个组中，监听同一个队列。具有如下特点：</p>
<ol>
<li>消息分流：队列中的消息会分流给组内的不同消费者，而不是重复消费，从而加快消息处理的速度</li>
<li>消息标示：消费者组会维护一个标示，记录最后一个被处理的消息，哪怕消费者宕机重启，还会从标示之后读取消息。确保每一个消息都会被消费</li>
<li>消息确认：消费者获取消息后，消息处于pending状态，并存入一个pending-list。当处理完成后需要通过XACK来确认消息，标记该消息为已处理，才会从pending-list移除</li>
</ol>
<p>创建消费者组：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XGROUP CREATE key groupName ID [MKSTREAM]</span><br></pre></td></tr></table></figure>

<ul>
<li>key：队列名称</li>
<li>groupName：消费者组名称</li>
<li>ID：起始ID标示，￥标示队列中最后一个消息，0则代表队列中第一个消息</li>
<li>MKSTREAM：队列不存在时自动创建队列</li>
</ul>
<p>其他常见命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的消费者组</span></span><br><span class="line">XGROUP DESTROY key groupName</span><br><span class="line"><span class="meta">#</span><span class="bash"> 给指定的消费者组天假消费者</span></span><br><span class="line">XGROUP CREATECONSUMER key groupname consumername</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除消费者组中的指定消费者</span></span><br><span class="line">XGROUP DELCONSUMER key groupname consumername</span><br></pre></td></tr></table></figure>

<p>从消费者组读取消息：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>

<ul>
<li>group：消费组名称</li>
<li>consumer：消费者名称，如果消费者不存在，会自动创建一个消费者</li>
<li>count：本次查询的最大数量</li>
<li>BLOCK milliseconds：当没有消息时最长等待时间</li>
<li>NOACK：无需手动ACK，获取到消息后自动确认</li>
<li>STREAMS key：指定消息名称</li>
<li>ID：获取消息的起始ID：<ul>
<li>“&gt;”：从下一个未消费的消息开始</li>
<li>其它：根据指定id从pending-list中获取已消费但未确认的消息，例如0，是从pending-list中的第一个消息开始</li>
</ul>
</li>
</ul>
<h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul>
<li>消息可回溯</li>
<li>可以多消费者争抢消息，加快消费速度</li>
<li>可以阻塞读取</li>
<li>没有消费漏读风险</li>
<li>有消息确认机制，保证消息至少被消费一次</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/07/21/Spring/" rel="prev" title="SpringFrame">
      <i class="fa fa-chevron-left"></i> SpringFrame
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Redis%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="nav-number">1.</span> <span class="nav-text">Redis基础使用</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NoSQL%E7%89%B9%E6%80%A7"><span class="nav-number">1.1.</span> <span class="nav-text">NoSQL特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.</span> <span class="nav-text">Redis特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">Redis数据结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E9%80%9A%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="nav-number">1.4.</span> <span class="nav-text">Redis通用命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4"><span class="nav-number">1.5.</span> <span class="nav-text">String类型命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#key%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">1.6.</span> <span class="nav-text">key的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hash%E7%B1%BB%E5%9E%8B%E5%91%BD%E4%BB%A4"><span class="nav-number">1.7.</span> <span class="nav-text">Hash类型命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.8.</span> <span class="nav-text">List类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.9.</span> <span class="nav-text">Set类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SortedSet%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.10.</span> <span class="nav-text">SortedSet类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Jedis"><span class="nav-number">2.</span> <span class="nav-text">Jedis</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#SpringDataRedis"><span class="nav-number">3.</span> <span class="nav-text">SpringDataRedis</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringDataRedis%E5%BF%AB%E9%80%9F%E4%BD%BF%E7%94%A8"><span class="nav-number">3.1.</span> <span class="nav-text">SpringDataRedis快速使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><span class="nav-number">3.1.1.</span> <span class="nav-text">引入依赖</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">3.1.2.</span> <span class="nav-text">配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%85%A5RedisTemplate"><span class="nav-number">3.1.3.</span> <span class="nav-text">注入RedisTemplate</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SpringDataRedis%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">SpringDataRedis的序列化方式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%AE%9E%E6%88%98"><span class="nav-number">4.</span> <span class="nav-text">实战</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Session%E5%AE%9E%E7%8E%B0%E7%94%A8%E6%88%B7%E7%9F%AD%E4%BF%A1%E7%99%BB%E5%BD%95"><span class="nav-number">4.1.</span> <span class="nav-text">Session实现用户短信登录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%93%E5%AD%98"><span class="nav-number">4.2.</span> <span class="nav-text">缓存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%9A%84%E7%AE%80%E4%BB%8B"><span class="nav-number">4.2.1.</span> <span class="nav-text">缓存的简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B7%BB%E5%8A%A0Redis%E7%BC%93%E5%AD%98"><span class="nav-number">4.2.2.</span> <span class="nav-text">添加Redis缓存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">4.2.3.</span> <span class="nav-text">缓存更新策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5"><span class="nav-number">4.2.4.</span> <span class="nav-text">主动更新策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="nav-number">4.2.5.</span> <span class="nav-text">缓存穿透</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="nav-number">4.2.6.</span> <span class="nav-text">缓存雪崩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="nav-number">4.2.7.</span> <span class="nav-text">缓存击穿</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">4.3.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B9%90%E8%A7%82%E9%94%81"><span class="nav-number">4.3.1.</span> <span class="nav-text">乐观锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS%E6%B3%95"><span class="nav-number">4.3.1.1.</span> <span class="nav-text">CAS法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">4.3.2.</span> <span class="nav-text">分布式锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8ERedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">4.3.2.1.</span> <span class="nav-text">基于Redis的分布式锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%94%B9%E8%BF%9BRedis%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="nav-number">4.3.2.2.</span> <span class="nav-text">改进Redis的分布式锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Redis%E7%9A%84Lua%E8%84%9A%E6%9C%AC"><span class="nav-number">4.3.2.3.</span> <span class="nav-text">Redis的Lua脚本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redisson"><span class="nav-number">4.4.</span> <span class="nav-text">Redisson</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE"><span class="nav-number">4.4.1.</span> <span class="nav-text">配置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redisson%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">4.4.2.</span> <span class="nav-text">Redisson可重入锁的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">4.4.3.</span> <span class="nav-text">Redisson分布式的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Redisson%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">4.4.4.</span> <span class="nav-text">Redisson分布式锁主从一致性问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">4.5.</span> <span class="nav-text">消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EList%E7%BB%93%E6%9E%84%E6%A8%A1%E6%8B%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">4.5.1.</span> <span class="nav-text">基于List结构模拟消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9"><span class="nav-number">4.5.1.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9"><span class="nav-number">4.5.1.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EPubSub%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">4.5.2.</span> <span class="nav-text">基于PubSub的消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%98%E7%82%B9-1"><span class="nav-number">4.5.2.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="nav-number">4.5.2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="nav-number">4.5.3.</span> <span class="nav-text">基于Stream的消息队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9"><span class="nav-number">4.5.3.1.</span> <span class="nav-text">特点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8EStream%E7%9A%84%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84"><span class="nav-number">4.5.4.</span> <span class="nav-text">基于Stream的消息队列-消费者组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%89%B9%E7%82%B9-1"><span class="nav-number">4.5.4.1.</span> <span class="nav-text">特点</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">MANVND</p>
  <div class="site-description" itemprop="description">There is no royal road to learning</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">MANVND</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
